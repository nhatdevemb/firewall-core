// backend/server.js

const express = require('express');
const fetch = require('node-fetch'); // ƒê·ªÉ fetch n·ªôi dung t·ª´ URL
const path = require('path');
const fs = require('fs');
const os = require('os');
const axios = require('axios');
const diff = require('diff');
const { exec } = require('child_process');
const { spawn } = require('child_process');
const multer = require('multer');
const bodyParser = require('body-parser');
const sqlite3 = require('sqlite3').verbose();
const session = require('express-session');
const crypto = require('crypto'); // ƒê·ªÉ t√≠nh m√£ bƒÉm (hash)
const { Client } = require('ssh2');
const { Server } = require('ws');

require('dotenv').config(); // Th√™m d√≤ng n√†y ƒë·ªÉ s·ª≠ d·ª•ng dotenv

// backend/server.js
const { executeCommand } = require('./commands/sshExecutor');

const app = express();
const port = 1234;

// Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ th√¥ng tin SSH
let globalSshInfo = {};

// TƒÉng gi·ªõi h·∫°n k√≠ch th∆∞·ªõc payload
app.use(bodyParser.json({ limit: '10mb' })); // Cho ph√©p payload JSON l√™n ƒë·∫øn 10MB
app.use(bodyParser.urlencoded({ limit: '10mb', extended: true }));

// Thi·∫øt l·∫≠p session !!!!!!!!!!!!!!!!!!!!!!
app.use(session({
    secret: 'your_super_secret_key', // Thay b·∫±ng m·ªôt kh√≥a b√≠ m·∫≠t m·∫°nh
    resave: false,
    saveUninitialized: true,
    cookie: { secure: false } // ƒê·∫∑t secure: true khi s·ª≠ d·ª•ng HTTPS
}));


// ƒê·∫∑t th∆∞ m·ª•c public l√†m static
app.use(express.static(path.join(__dirname, '../public')));

// Route GET '/' chuy·ªÉn h∆∞·ªõng ƒë·∫øn '/login' n·∫øu ch∆∞a ƒëƒÉng nh·∫≠p ho·∫∑c '/index' n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p
app.get('/', (req, res) => {
    if (req.session.isAuthenticated) {
        res.redirect('/index.html');
    } else {
        res.redirect('/login');
    }
});

// Route GET '/login' ƒë·ªÉ ph·ª•c v·ª• trang login.html
app.get('/login', (req, res) => {
    res.sendFile(path.join(__dirname, '../public/html', 'login.html'));
});

// Route POST '/login' ƒë·ªÉ x·ª≠ l√Ω ƒëƒÉng nh·∫≠p v√† l∆∞u th√¥ng tin thi·∫øt b·ªã v√†o session
app.post('/login', (req, res) => {
    const { deviceId } = req.body; // L·∫•y deviceId t·ª´ body

    console.log('Received device ID:', deviceId);  // Log gi√° tr·ªã deviceId nh·∫≠n ƒë∆∞·ª£c t·ª´ frontend

    // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ cung c·∫•p ƒë·ªß th√¥ng tin ch∆∞a
    if (!deviceId) {
        return res.status(400).json({ message: 'Vui l√≤ng ch·ªçn thi·∫øt b·ªã.' });
    }

    const db = new sqlite3.Database('devices.db'); // ƒê·∫£m b·∫£o ƒë∆∞·ªùng d·∫´n ƒë√∫ng c·ªßa c∆° s·ªü d·ªØ li·ªáu

    db.get('SELECT * FROM devices WHERE id = ?', [deviceId], (err, row) => {
        if (err) {
            console.error('Database error:', err);  // Log chi ti·∫øt l·ªói truy v·∫•n
            return res.status(500).json({ message: 'Database error', error: err });
        }

        if (!row) {
            console.log('No device found with ID:', deviceId);  // Log khi kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã
            return res.status(404).json({ message: 'Thi·∫øt b·ªã kh√¥ng t√¨m th·∫•y' });
        }

        console.log('Device details:', row);  // Log th√¥ng tin thi·∫øt b·ªã

        // L∆∞u th√¥ng tin thi·∫øt b·ªã v√†o session
        req.session.deviceInfo = row;

        res.json({ message: 'Login successful!' });
    });
});

// Middleware ki·ªÉm tra x√°c th·ª±c
function isAuthenticated(req, res, next) {
    if (req.session.deviceInfo) {
        // N·∫øu ƒë√£ c√≥ th√¥ng tin thi·∫øt b·ªã trong session, ki·ªÉm tra t√≠nh h·ª£p l·ªá trong DB
        const deviceId = req.session.deviceInfo.id;

        const db = new sqlite3.Database('devices.db'); // ƒê·∫£m b·∫£o ƒë∆∞·ªùng d·∫´n ƒë√∫ng c·ªßa c∆° s·ªü d·ªØ li·ªáu

        db.get('SELECT * FROM devices WHERE id = ?', [deviceId], (err, row) => {
            if (err) {
                console.error('Error querying database:', err);
                return res.status(500).json({ message: 'Database error' });
            }

            if (!row) {
                return res.status(404).json({ message: 'Device not found' });
            }

            // Thi·∫øt b·ªã h·ª£p l·ªá, ti·∫øp t·ª•c
            req.session.deviceInfo = row;
            next();
        });
    } else {
        // N·∫øu kh√¥ng c√≥ th√¥ng tin thi·∫øt b·ªã trong session, y√™u c·∫ßu ƒëƒÉng nh·∫≠p l·∫°i
        res.redirect('/login');
    }
}

//============================================================================================================================//
// Route GET '/index' ƒë·ªÉ ph·ª•c v·ª• trang index.html sau khi ƒëƒÉng nh·∫≠p th√†nh c√¥ng
app.get('/index.html',  (req, res) => {
    res.sendFile(path.join(__dirname, '../public/html', 'index.html'));
});

//============================================================================================================================//
// Route GET '/logout' ƒë·ªÉ ƒëƒÉng xu·∫•t ng∆∞·ªùi d√πng
app.get('/logout', (req, res) => {
    req.session.destroy((err) => {
        if (err) {
            console.error('Error destroying session:', err);
            return res.redirect('/index.html');
        }
        res.clearCookie('connect.sid'); // T√™n cookie m·∫∑c ƒë·ªãnh
        res.redirect('/login');
    });
});



//============================================================================================================================//
// ƒëƒÉng k√Ω thi·∫øt b·ªã


// K·∫øt n·ªëi t·ªõi c∆° s·ªü d·ªØ li·ªáu SQLite (ho·∫∑c t·∫°o m·ªõi n·∫øu ch∆∞a t·ªìn t·∫°i)
// K·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu SQLite
const db = new sqlite3.Database('./devices.db', (err) => {
    if (err) {
        console.error('Error opening database:', err);
    } else {
        console.log('Connected to SQLite database');
    }
});

// T·∫°o b·∫£ng devices n·∫øu ch∆∞a c√≥
db.run(`
    CREATE TABLE IF NOT EXISTS devices (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_name TEXT NOT NULL,
        device_ip TEXT NOT NULL,
        device_user_name TEXT NOT NULL,
        device_password TEXT NOT NULL
    )
`);


// API ƒë·ªÉ l·∫•y danh s√°ch thi·∫øt b·ªã ƒë√£ ƒëƒÉng k√Ω
app.get('/get-registered-devices', (req, res) => {
    db.all('SELECT * FROM devices', [], (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json(rows);
    });
});


// API ƒë·ªÉ l·∫•y th√¥ng tin thi·∫øt b·ªã theo id
app.get('/get-device-details/:id', (req, res) => {
    const deviceId = req.params.id;  // L·∫•y deviceId t·ª´ URL params

    const db = new sqlite3.Database('devices.db');  // ƒê·∫£m b·∫£o ƒë∆∞·ªùng d·∫´n ƒë√∫ng c·ªßa c∆° s·ªü d·ªØ li·ªáu

    // Truy v·∫•n ƒë·ªÉ l·∫•y th√¥ng tin thi·∫øt b·ªã t·ª´ c∆° s·ªü d·ªØ li·ªáu
    db.get('SELECT * FROM devices WHERE id = ?', [deviceId], (err, row) => {
        if (err) {
            console.error('Database error:', err);
            return res.status(500).json({ message: 'Database error', error: err });
        }

        if (!row) {
            console.log('No device found with ID:', deviceId);
            return res.status(404).json({ message: 'Thi·∫øt b·ªã kh√¥ng t√¨m th·∫•y' });
        }

        // Tr·∫£ v·ªÅ th√¥ng tin thi·∫øt b·ªã d∆∞·ªõi d·∫°ng JSON
        res.json(row);
        db.close();
    });
});

// Route POST '/save-device-session' ƒë·ªÉ l∆∞u th√¥ng tin thi·∫øt b·ªã v√†o session
app.post('/save-device-session', (req, res) => {
    const deviceInfo = req.body; // L·∫•y th√¥ng tin thi·∫øt b·ªã t·ª´ body

    if (!deviceInfo) {
        return res.status(400).json({ message: 'Kh√¥ng c√≥ th√¥ng tin thi·∫øt b·ªã ƒë·ªÉ l∆∞u v√†o session.' });
    }

    // L∆∞u th√¥ng tin thi·∫øt b·ªã v√†o session
    req.session.deviceInfo = deviceInfo;

    // T·∫°o th√¥ng tin SSH t·ª´ deviceInfo
    const sshInfo = {
        address: deviceInfo.deviceIP,  // ƒê·ªãa ch·ªâ IP c·ªßa thi·∫øt b·ªã
        pass: deviceInfo.devicePassword // M·∫≠t kh·∫©u c·ªßa thi·∫øt b·ªã
    };

    // L∆∞u th√¥ng tin SSH v√†o session
    req.session.sshInfo = sshInfo;

    // Tr·∫£ v·ªÅ th√¥ng b√°o th√†nh c√¥ng
    res.json({ message: 'Th√¥ng tin thi·∫øt b·ªã v√† SSH ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o session.' });
});



// API ƒë·ªÉ ƒëƒÉng k√Ω thi·∫øt b·ªã m·ªõi
app.post('/register-device', (req, res) => {
    const { deviceName, deviceIP, deviceUserName, devicePassword } = req.body;

    console.log("Received data:", deviceName, deviceIP, deviceUserName, devicePassword); // Ki·ªÉm tra d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c

    if (!deviceName || !deviceIP || !deviceUserName || !devicePassword) {
        return res.status(400).json({ success: false, message: 'T·∫•t c·∫£ c√°c tr∆∞·ªùng th√¥ng tin ƒë·ªÅu b·∫Øt bu·ªôc!' });
    }

    const query = 'INSERT INTO devices (device_name, device_ip, device_user_name, device_password) VALUES (?, ?, ?, ?)';
    db.run(query, [deviceName, deviceIP, deviceUserName, devicePassword], function(err) {
        if (err) {
            console.error("Error during DB insertion:", err.message); // In ra l·ªói n·∫øu c√≥
            return res.status(500).json({ success: false, message: err.message });
        }
        res.status(200).json({ success: true, message: 'Device registered successfully!', id: this.lastID });
    });
});


// API ƒë·ªÉ x√≥a thi·∫øt b·ªã
app.delete('/delete-device/:id', (req, res) => {
    const deviceId = req.params.id;

    const query = 'DELETE FROM devices WHERE id = ?';
    db.run(query, [deviceId], function (err) {
        if (err) {
            console.error("Error deleting device:", err.message);
            return res.status(500).json({ success: false, message: 'Kh√¥ng th·ªÉ x√≥a thi·∫øt b·ªã!' });
        }
        if (this.changes === 0) {
            return res.status(404).json({ success: false, message: 'Thi·∫øt b·ªã kh√¥ng t√¨m th·∫•y!' });
        }
        res.status(200).json({ success: true, message: 'Thi·∫øt b·ªã ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng!' });
    });
});



//============================================================================================================================//
// ƒëƒÉng k√Ω thi·∫øt b·ªã
//============================================================================================================================//



//============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë l∆∞·ª£ng rules categories
app.get('/api/rules/count',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        const count = await executeCommand(address, 'root', pass, 'ls -1 /etc/suricata/rules/*.rules 2>/dev/null | wc -l');
        res.json({ count });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë l∆∞·ª£ng rules ƒëang c√≥
app.get('/api/rules/countall',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        // L·ªánh t√¨m t·∫•t c·∫£ c√°c file c√≥ ƒëu√¥i .rules trong th∆∞ m·ª•c /etc/suricata/rules/
        // Sau ƒë√≥ ƒë·∫øm s·ªë d√≤ng c√≥ ch·ª©a "sid" ho·∫∑c "SID"
        const command = `
            find /etc/suricata/rules/ -type f -name "*.rules" | 
            xargs grep -E "sid|SID" | 
            wc -l
        `;

        // Th·ª±c thi l·ªánh tr√™n thi·∫øt b·ªã t·ª´ xa
        const count = await executeCommand(address, 'root', pass, command.trim());

        // Tr·∫£ k·∫øt qu·∫£ v·ªÅ client
        res.json({ count: parseInt(count.trim(), 10) }); // Chuy·ªÉn chu·ªói k·∫øt qu·∫£ th√†nh s·ªë nguy√™n
    } catch (error) {
        console.error('Error executing command:', error.message);
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});


//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë th√¥ng s·ªë RAM
app.get('/api/system/ram',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        const count = await executeCommand(address, 'root', pass, "free -h | awk '/Mem:/ {print $3 \"/\" $2}'");
        res.json({ count });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë th√¥ng s·ªë 
app.get('/api/system/cpu',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        // T·∫°o ƒë·ªô tr·ªÖ 1.5 gi√¢y tr∆∞·ªõc khi th·ª±c thi l·ªánh
        setTimeout(async () => {
            // Th·ª±c thi l·ªánh ƒë·ªÉ l·∫•y th√¥ng tin CPU
            const usecpu = await executeCommand(address, 'root', pass, "top -bn1 | grep 'Cpu(s)' | sed \"s/%Cpu(s):/ /\" | awk '{print 100 - $7}'");
            
            // Tr·∫£ v·ªÅ k·∫øt qu·∫£ cho client
            res.json({ usecpu });

        }, 800); // 1500 milliseconds = 1.5 seconds
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë th√¥ng s·ªë o cung ghi log
app.get('/api/system/logdisk',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        const count = await executeCommand(address, 'root', pass, `df -h | awk '$NF=="/mnt/my_storage" {print $3"/"$2}'`);
        res.json({ count });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

// ƒê∆∞·ªùng d·∫´n t·ªõi file log
const logFilePath = '/var/log/firewall_requests.json';
const userLogFilePath = '/var/log/user_pass.json';

// B·ªô nh·ªõ t·∫°m th·ªùi l∆∞u request t·ª´ firewall
let firewallRequests = [];
let userLoginRequests = [];

// üî• H√†m ghi log v√†o file üî•
function appendToFirewallLog(entry) {
    let logs = [];
    if (fs.existsSync(logFilePath)) {
        const fileContent = fs.readFileSync(logFilePath, 'utf8');
        try {
            logs = JSON.parse(fileContent);
        } catch (error) {
            console.error("Error parsing firewall log file:", error);
        }
    }
    logs.unshift(entry);
    if (logs.length > 500) {
        logs.pop();
    }
    fs.writeFileSync(logFilePath, JSON.stringify(logs, null, 2));
}

function appendToUserLog(entry) {
    let logs = [];
    if (fs.existsSync(userLogFilePath)) {
        const fileContent = fs.readFileSync(userLogFilePath, 'utf8');
        try {
            logs = JSON.parse(fileContent);
        } catch (error) {
            console.error("Error parsing user login log file:", error);
        }
    }
    logs.unshift(entry);
    if (logs.length > 500) {
        logs.pop();
    }
    fs.writeFileSync(userLogFilePath, JSON.stringify(logs, null, 2));
}

// üî• API nh·∫≠n d·ªØ li·ªáu t·ª´ firewall (mac log) üî•
// üî• API nh·∫≠n d·ªØ li·ªáu t·ª´ firewall (mac log) üî•
// üî• API nh·∫≠n d·ªØ li·ªáu t·ª´ firewall (mac log) üî•
app.post('/api/firewall/logs/mac', (req, res) => {
    const { mac, status, name, ip, reason } = req.body;  // Nh·∫≠n th√™m "reason"
    const timestamp = new Date().toISOString();

    console.log(`[INFO] Update from Firewall: MAC=${mac}, Status=${status}, Name=${name}, IP=${ip}, Reason=${reason}`);

    const newRequest = { mac, status, name, ip, reason, timestamp }; // Th√™m "reason" v√†o request
    firewallRequests.unshift(newRequest);
    appendToFirewallLog(newRequest);  // L∆∞u v√†o log

    res.json({ message: 'Update received and logged', mac, status, name, ip, reason });
});



// üî• API nh·∫≠n d·ªØ li·ªáu t·ª´ firewall (user log) üî•
app.post('/api/firewall/logs/username', (req, res) => {
    const { username, ip, status, reason } = req.body;
    const timestamp = new Date().toISOString();

    console.log(`[INFO] Update from Firewall: Username=${username}, IP=${ip}, Status=${status}, Reason=${reason}`);

    const newRequest = { timestamp, username, ip, status, reason };
    userLoginRequests.unshift(newRequest);
    appendToUserLog(newRequest);

    res.json({ message: 'Update received and logged', username, ip, status, reason });
});

// üî• API l·∫•y request m·ªõi nh·∫•t (mac log) üî•
app.get('/api/firewall/logs/mac', (req, res) => {
    res.json({ message: "Live firewall MAC logs", logs: firewallRequests });
});

// üî• API l·∫•y request m·ªõi nh·∫•t (user log) üî•
app.get('/api/firewall/logs/username', (req, res) => {
    res.json({ message: "Live user login logs", logs: userLoginRequests });
});

// üî• API l·∫•y s·ªë request ch∆∞a ƒë·ªçc (mac log) üî•
app.get('/api/firewall/new-requests/mac', (req, res) => {
    res.json({ count: firewallRequests.length });
});

// üî• API l·∫•y s·ªë request ch∆∞a ƒë·ªçc (user log) üî•
app.get('/api/firewall/new-requests/username', (req, res) => {
    res.json({ count: userLoginRequests.length });
});

// üî• API reset request sau khi m·ªü popup (mac log) üî•
app.post('/api/firewall/reset-requests/mac', (req, res) => {
    firewallRequests = [];
    res.json({ message: "MAC Requests reset successfully" });
});

// üî• API reset request sau khi m·ªü popup (user log) üî•
app.post('/api/firewall/reset-requests/username', (req, res) => {
    userLoginRequests = [];
    res.json({ message: "User Login Requests reset successfully" });
});

// üî• API ƒë·ªçc to√†n b·ªô log t·ª´ file (mac log) üî•
app.get('/api/firewall/full-log/mac', (req, res) => {
    if (!fs.existsSync(logFilePath)) {
        return res.json({ logs: [] });
    }

    try {
        const data = fs.readFileSync(logFilePath, 'utf8');
        const logs = JSON.parse(data);
        res.json({ logs });
    } catch (error) {
        res.status(500).json({ message: "Error reading log file", error: error.message });
    }
});

// üî• API ƒë·ªçc to√†n b·ªô log t·ª´ file (user log) üî•
app.get('/api/firewall/full-log/username', (req, res) => {
    if (!fs.existsSync(userLogFilePath)) {
        return res.json({ logs: [] });
    }

    try {
        const data = fs.readFileSync(userLogFilePath, 'utf8');
        const logs = JSON.parse(data);
        res.json({ logs });
    } catch (error) {
        res.status(500).json({ message: "Error reading user login log file", error: error.message });
    }
});





//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë th√¥ng s·ªë thoi gian thiet bi hoat dong ke tu lan cuoi
app.get('/api/system/checkTimehoatdong',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        const count = await executeCommand(address, 'root', pass, `uptime | awk -F'( up |, 1 user|,  [0-9] user|, load average)' '{print $2}'`);
        res.json({ count });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});


//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë th√¥ng s·ªë nhiet do CPU
app.get('/api/system/tempCPU',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        // Th·ª±c thi l·ªánh ƒë·ªÉ l·∫•y nhi·ªát ƒë·ªô CPU
        const output = await executeCommand(address, 'root', pass, `sensors | awk '/temp1:/ {print $2 $3} /temp2:/ {print $2 $3}'`);

        // T√°ch k·∫øt qu·∫£ th√†nh m·∫£ng
        const temps = output.trim().split('\n');

        // T·∫°o JSON v·ªõi ch·ªâ nhi·ªát ƒë·ªô
        const result = {
            core1: temps[0] || 'N/A', // Nhi·ªát ƒë·ªô Core 1
            core2: temps[1] || 'N/A'  // Nhi·ªát ƒë·ªô Core 2
        };

        res.json(result); // Tr·∫£ v·ªÅ JSON
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë th√¥ng s·ªë nhiet do CPU
app.get('/api/system/hanlicense',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        const count = await executeCommand(address, 'root', pass, 'cat /etc/suricata/license');
        res.json({ count });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});




//============================================================================================================================//
// H√†m escape c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát trong t·ª´ kh√≥a cho grep
function escapeKeywordForGrep(keyword) {
    return keyword.replace(/([\\\[\]\*\?\$\^\{\}\|])/g, '\\$&');
}

// Route ƒë·ªÉ t√¨m ki·∫øm rule trong c√°c file rules
app.post('/api/rules/timvasua',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session
    let keyword = req.body.keyword.trim(); // L·∫•y t·ª´ kh√≥a t·ª´ request

    if (!keyword) {
        return res.status(400).json({ message: 'Keyword is required' });
    }

    // Escape t·ª´ kh√≥a ƒë·ªÉ tr√°nh c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát g√¢y l·ªói
    keyword = escapeKeywordForGrep(keyword);

    try {
        // S·ª≠ d·ª•ng l·ªánh grep ƒë·ªÉ t√¨m t·ª´ kh√≥a trong c√°c file c√≥ ƒëu√¥i .rules
        const command = `grep -rnw '/etc/suricata/rules' -e '${keyword}' --include=*.rules`;
        console.log(`ƒêang ch·∫°y l·ªánh: ${command}`); // Log l·ªánh grep ƒë·ªÉ ki·ªÉm tra
        const searchResult = await executeCommand(address, 'root', pass, command);

        if (!searchResult) {
            return res.json({ message: 'No matching rules found' });
        }

        // Ph√¢n t√≠ch k·∫øt qu·∫£ grep ƒë·ªÉ tr·∫£ v·ªÅ file, d√≤ng v√† n·ªôi dung
        const results = searchResult.split('\n').filter(line => line).map(line => {
            const [file, lineNumber, ...content] = line.split(':');
            return {
                file,
                line: parseInt(lineNumber, 10),
                content: content.join(':').trim()
            };
        });

        res.json({ results });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});



//============================================================================================================================//
// Route ƒë·ªÉ sua rule
//============================================================================================================================//
// Route ƒë·ªÉ s·ª≠a rule
// Route ƒë·ªÉ s·ª≠a rule v√† ki·ªÉm tra
app.post('/api/rules/update',  async (req, res) => {
    const { address, pass } = req.session.sshInfo;
    const { file, sid, newAction, newProtocol, newSource, newSourcePort, newDestination, newDestinationPort } = req.body;

    console.log('Received data:', { file, sid, newAction, newProtocol, newSource, newSourcePort, newDestination, newDestinationPort });

    if (!file || !sid || !newAction || !newProtocol || !newSource || !newSourcePort || !newDestination || !newDestinationPort) {
        return res.status(400).json({ message: 'File, SID, and all new fields are required' });
    }

    try {
        const getLineCommand = `grep 'sid:\\s*${sid};' ${file}`;
        const originalLine = await executeCommand(address, 'root', pass, getLineCommand);

        console.log('Grep result:', originalLine);
        if (!originalLine) {
            return res.status(404).json({ message: 'Rule not found' });
        }

        // Ph√¢n t√≠ch d√≤ng quy t·∫Øc g·ªëc
        let [action, protocol, source, sourcePort, direction, destination, destinationPort, ...rest] = originalLine.split(' ');

        // TƒÉng gi√° tr·ªã rev n·∫øu c√≥
        const revRegex = /rev:\s*(\d+);/;
        let updatedRest = rest.join(' ');
        const revMatch = updatedRest.match(revRegex);

        if (revMatch) {
            const currentRev = parseInt(revMatch[1], 10); // L·∫•y gi√° tr·ªã rev hi·ªán t·∫°i
            const newRev = currentRev + 1; // TƒÉng rev l√™n 1
            updatedRest = updatedRest.replace(revRegex, `rev:${newRev};`); // Thay th·∫ø gi√° tr·ªã rev
        } else {
            return res.status(400).json({ message: 'Missing rev parameter in rule' });
        }

        // C·∫≠p nh·∫≠t ch·ªâ nh·ªØng ph·∫ßn ƒë√£ thay ƒë·ªïi
        action = newAction.startsWith('#') ? newAction : newAction;
        protocol = newProtocol;
        source = newSource;
        sourcePort = newSourcePort;
        destination = newDestination;
        destinationPort = newDestinationPort;

        const updatedLine = `${action} ${protocol} ${source} ${sourcePort} ${direction} ${destination} ${destinationPort} ${updatedRest}`;
        const escapedUpdatedLine = updatedLine.replace(/(["`\\])/g, '\\$1');

        const updateCommand = `sed -i '/sid:\\s*${sid};/c\\${escapedUpdatedLine}' ${file}`;
        await executeCommand(address, 'root', pass, updateCommand);

        // Ki·ªÉm tra v√† t·∫°o file t·∫°m n·∫øu ch∆∞a t·ªìn t·∫°i
        const tempFilePath = '/tmp/rulesua.rules';
        // const createTempFileCommand = `touch ${tempFilePath}`;
        // await executeCommand(address, 'root', pass, createTempFileCommand);

        // Ghi rule ƒë√£ s·ª≠a v√†o file t·∫°m
        // console.log("duyet beo", updatedLine);
        // Ghi n·ªôi dung rule v√†o file t·∫°m b·∫±ng c√°ch s·ª≠ d·ª•ng echo v√† > (ghi ƒë√®)
        const saveTempRuleCommand = `echo '${updatedLine}' > ${tempFilePath}`;
        await executeCommand(address, 'root', pass, saveTempRuleCommand);
        
        // Ki·ªÉm tra xem file t·∫°m ƒë√£ ghi th√†nh c√¥ng hay ch∆∞a
        const checkTempFileCommand = `cat ${tempFilePath}`;
        const checkTempFileOutput = await executeCommand(address, 'root', pass, checkTempFileCommand);
        console.log('Temporary rule file content:', checkTempFileOutput);


        // Ch·∫°y script ki·ªÉm tra rule tr√™n file t·∫°m
        const checkTempRuleCommand = `/usr/local/etc/chowebApp/kiemtrarule.sh ${tempFilePath}`;
        const checkResult = await executeCommand(address, 'root', pass, checkTempRuleCommand);

        // Ki·ªÉm tra k·∫øt qu·∫£ t·ª´ script
        if (checkResult.includes('T·ªïng s·ªë rule sai: 0')) {
            // N·∫øu kh√¥ng c√≥ l·ªói, restart Suricata
            const restartCommand = `/usr/local/etc/chowebApp/restart_suricata.sh`;
            await executeCommand(address, 'root', pass, restartCommand);

            // X√≥a file t·∫°m sau khi ki·ªÉm tra
            // const deleteTempFileCommand = `rm -f ${tempFilePath}`;
            // await executeCommand(address, 'root', pass, deleteTempFileCommand);

            return res.json({ message: 'S·ª≠a rule th√†nh c√¥ng' });
        } else {
            // Ph√¢n t√≠ch l·ªói t·ª´ k·∫øt qu·∫£ script
            const errorLines = checkResult.split('\n').filter(line => line.includes('T·ªïng s·ªë rule sai') || line.includes('N·ªôi dung rule ƒë·∫ßy ƒë·ªß') || line.includes('V·ªã tr√≠:'));
            
            return res.status(400).json({
                message: 'C√≥ l·ªói trong rule',
                errors: errorLines.join('\n')
            });
        }
    } catch (error) {
        res.status(500).json({ message: 'Error updating rule', error: error.message });
    }
});

//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y s·ªë th√¥ng s·ªë HA
app.get('/api/system/ha', async (req, res) => {
    const { address, pass } = req.session.sshInfo || {};

    if (!address || !pass) {
        return res.status(400).json({ message: 'Missing SSH credentials' });
    }

    try {
        // Th·ª±c hi·ªán l·ªánh ƒë·ªÉ l·∫•y tr·∫°ng th√°i
        const result = await executeCommand(address, 'root', pass, "for iface in fm2-mac2 fm2-mac1; do ip addr show $iface | grep 192.168.2.196; done");

        // Ki·ªÉm tra xem c√≥ k·∫øt qu·∫£ tr·∫£ v·ªÅ kh√¥ng
        const status = result.trim() ? 'Active' : 'Deactive'; // N·∫øu c√≥ k·∫øt qu·∫£ tr·∫£ v·ªÅ th√¨ status l√† 'on', ng∆∞·ª£c l·∫°i l√† 'off'

        res.json({ status }); // Tr·∫£ v·ªÅ tr·∫°ng th√°i
    } catch (error) {
        console.error('Error executing command:', error); // Log l·ªói n·∫øu c√≥
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//=============================================================================================================================//
// Route ƒë·ªÉ t√¨m ki·∫øm rules v·ªõi g·ª£i √Ω
app.post('/api/rules/search',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session
    const keyword = req.body.keyword.toLowerCase();

    try {
        const command = 'ls /etc/suricata/rules';
        const result = await executeCommand(address, 'root', pass, command);
        const files = result.split('\n').filter(file => file.toLowerCase().includes(keyword));
        res.json({ files });
    } catch (error) {
        res.status(500).json({ message: 'Error searching rules', error: error.message });
    }
});

//=============================================================================================================================//
// Route ƒë·ªÉ th·ª±c thi l·ªánh cat khi ng∆∞·ªùi d√πng ch·ªçn m·ªôt rule
app.post('/api/rules/execute',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session
    const filename = req.body.filename;

    try {
        // L·ªánh cat ƒë·ªÉ sao ch√©p n·ªôi dung file rule v√†o /tmp/xemrule.rules
        const command = `cat /etc/suricata/rules/${filename} > /tmp/xemrule.rules`;
        await executeCommand(address, 'root', pass, command);
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//=============================================================================================================================//
// ƒê∆∞·ªùng d·∫´n t·ªõi file xemrule.rules trong th∆∞ m·ª•c /tmp
const remoteFilePath = '/tmp/xemrule.rules';


function parseRulesFile(fileContent) {
    const lines = fileContent.split('\n');
    const rules = [];

    lines.forEach(line => {
        // B·ªè qua d√≤ng tr·ªëng
        if (line.trim() === '') return;

        const rule = {};

        // 1. Tr√≠ch xu·∫•t Action (Ch·ªâ l·∫•y n·∫øu action l√† #alert, #drop, #reject, #pass ho·∫∑c alert, drop, reject, pass)
        const actionMatch = line.match(/^(#?(alert|drop|reject|pass))/);  // L·∫•y action v·ªõi ho·∫∑c kh√¥ng c√≥ d·∫•u #
        if (!actionMatch) return;  // N·∫øu kh√¥ng ph√π h·ª£p, b·ªè qua d√≤ng n√†y
        rule.action = actionMatch[0];  // Gi·ªØ nguy√™n gi√° tr·ªã ƒë·∫ßy ƒë·ªß c·ªßa action, k·ªÉ c·∫£ d·∫•u #

        // 2. Tr√≠ch xu·∫•t SID
        const sidMatch = line.match(/sid:\s*(\d+)\s*;/);  // Th√™m kho·∫£ng tr·∫Øng linh ho·∫°t tr∆∞·ªõc v√† sau d·∫•u ':'
        rule.sid = sidMatch ? sidMatch[1] : 'Unknown';

        // 3. Tr√≠ch xu·∫•t MSG
        const msgMatch = line.match(/msg:\s*"([^"]*)"\s*;/);  // Ch·ªâ l·∫•y ph·∫ßn ch·ªØ n·∫±m gi·ªØa d·∫•u ngo·∫∑c k√©p ""
        rule.msg = msgMatch ? msgMatch[1] : 'Unknown';
        

        // 4. Tr√≠ch xu·∫•t Protocol
        const parts = line.split(/\s+/);  // T√°ch d√≤ng th√†nh c√°c ph·∫ßn d·ª±a tr√™n kho·∫£ng tr·∫Øng
        rule.protocol = parts[1] || 'Unknown';  // L·∫•y tr∆∞·ªùng th·ª© 2 l√† protocol

        // 5. Tr∆∞·ªùng Source v√† Destination gi·ªØ nguy√™n
        rule.src = parts[2] + ' ' + parts[3];  // Tr∆∞·ªùng th·ª© 3 v√† 4 l√† Source (VD: $EXTERNAL_NET any)
        rule.dst = parts[5] + ' ' + parts[6];  // Tr∆∞·ªùng th·ª© 6 v√† 7 l√† Destination (VD: $HOME_NET any)

        // 6. Tr√≠ch xu·∫•t Severity ch·ªâ t·ª´ signature_severity
        const severityMatch = line.match(/signature_severity\s*(\S+)\s*;/);  // T√¨m "signature_severity" v√† tr√≠ch xu·∫•t text
        rule.severity = severityMatch ? severityMatch[1] : 'Unknown';

        // Th√™m quy t·∫Øc v√†o m·∫£ng rules
        rules.push(rule);
    });

    return rules;
}

// H√†m ƒë·ªçc n·ªôi dung t·ª´ file remote
function readRemoteFile(address, username, password, remoteFilePath) {
    return new Promise((resolve, reject) => {
        const conn = new Client();
        let fileContent = '';

        conn.on('ready', () => {
            conn.exec(`cat ${remoteFilePath}`, (err, stream) => {
                if (err) {
                    reject(err);
                    conn.end();
                    return;
                }

                stream.on('data', (data) => {
                    fileContent += data.toString();
                }).on('close', () => {
                    resolve(fileContent);
                    conn.end();
                });
            });
        }).connect({
            host: address,
            port: 22,
            username: username,
            password: password,
        });
    });
}

//============================================================================================================================//
// Route ƒë·ªÉ tr·∫£ v·ªÅ d·ªØ li·ªáu rule ƒë√£ ƒë∆∞·ª£c parse
app.get('/api/rules',  async (req, res) => {
    const { address, pass } = req.session.sshInfo;

    try {
        const fileContent = await readRemoteFile(address, 'root', pass, remoteFilePath);
        const rulesData = parseRulesFile(fileContent);
        res.json(rulesData); // Tr·∫£ v·ªÅ d·ªØ li·ªáu JSON
    } catch (error) {
        res.status(500).json({ message: 'Error reading file', error: error.message });
    }
});
//========================================================//
// Route ƒë·ªÉ l·∫•y chi ti·∫øt rule d·ª±a tr√™n SID
// Route ƒë·ªÉ l·∫•y chi ti·∫øt rule d·ª±a tr√™n SID
app.get('/api/rule/:sid',  async (req, res) => {
    const { sid } = req.params;
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session (ƒë·ªãa ch·ªâ v√† m·∫≠t kh·∫©u thi·∫øt b·ªã IPS)

    try {
        // Ch·∫°y l·ªánh tr√™n thi·∫øt b·ªã IPS ƒë·ªÉ t√¨m rule d·ª±a tr√™n SID, v·ªõi kho·∫£ng tr·∫Øng linh ho·∫°t
        const command = `cat ${remoteFilePath} | grep -E 'sid\\s*:\\s*${sid}\\s*;'`;

        console.log(`ƒêang ch·∫°y l·ªánh: ${command}`);

        const ruleData = await executeCommand(address, 'root', pass, command);

        if (ruleData) {

            // S·ª≠ d·ª•ng h√†m parseRule ƒë·ªÉ ph√¢n t√≠ch c√∫ ph√°p ruleData
            const parsedRule = parseRule(ruleData);

            if (parsedRule) {
                res.json({
                    sid: parsedRule.sid,
                    msg: parsedRule.msg,
                    action: parsedRule.action,
                    protocol: parsedRule.protocol,
                    src: parsedRule.src,
                    dst: parsedRule.dst,
                    severity: parsedRule.severity,
                    fullRule: ruleData // To√†n b·ªô rule ƒë∆∞·ª£c tr·∫£ v·ªÅ nguy√™n b·∫£n
                });
            } else {
                res.status(400).json({ message: 'Invalid rule format' });
            }
        } else {
            res.status(404).json({ message: 'Rule not found' });
        }
    } catch (error) {
        console.error('L·ªói khi th·ª±c thi l·ªánh tr√™n IPS:', error);
        res.status(500).json({ message: 'L·ªói khi l·∫•y d·ªØ li·ªáu rule', error: error.message });
    }

});

// H√†m ti·ªÅn x·ª≠ l√Ω ƒë·ªÉ chu·∫©n h√≥a c√∫ ph√°p c·ªßa SID
function preprocessRule(ruleString) {
    // T√¨m t·∫•t c·∫£ c√°c tr∆∞·ªùng h·ª£p c√≥ t·ª´ 'sid' bao b·ªçc b·ªüi d·∫•u ';' nh∆∞ng kh√¥ng theo ƒë·ªãnh d·∫°ng chu·∫©n
    const sidPattern = /;\s*(sid)\s*:\s*(\d+)\s*;/g;

    // S·ª≠a t·∫•t c·∫£ c√°c tr∆∞·ªùng h·ª£p th√†nh d·∫°ng chu·∫©n "sid:<s·ªë sid>;"
    const fixedRuleString = ruleString.replace(sidPattern, '; sid:$2;');

    // In ra rule sau khi ƒë√£ s·ª≠a
    console.log("Rule sau khi s·ª≠a ƒë·ªãnh d·∫°ng SID:", fixedRuleString);

    return fixedRuleString;
}

// H√†m ph√¢n t√≠ch c√∫ ph√°p rule t·ª´ chu·ªói rule
function parseRule(ruleString) {
    try {
        // T√¨m v·ªã tr√≠ d·∫•u ngo·∫∑c ƒë∆°n ƒë·∫ßu ti√™n
        const openingParenIndex = ruleString.indexOf('(');

        if (openingParenIndex === -1) {
            throw new Error('Rule kh√¥ng h·ª£p l·ªá, thi·∫øu ph·∫ßn n·ªôi dung trong ngo·∫∑c ƒë∆°n');
        }

        // T√°ch actionPart v√† optionsPart
        const actionPart = ruleString.slice(0, openingParenIndex).trim();
        const optionsPart = ruleString.slice(openingParenIndex).trim();

        const actionParts = actionPart.split(/\s+/);
        const action = actionParts[0];

        // Ki·ªÉm tra action ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ l·∫•y c√°c action h·ª£p l·ªá
        if (!['#alert', '#drop', '#reject', '#pass', 'alert', 'drop', 'reject', 'pass'].includes(action)) {
            return null; // B·ªè qua n·∫øu kh√¥ng ph·∫£i action h·ª£p l·ªá
        }

        // D√πng regex ƒë·ªÉ t√¨m v√† s·ª≠a t·∫•t c·∫£ c√°c tr∆∞·ªùng h·ª£p SID trong rule
        let ruleStringModified = ruleString.replace(/sid\s*:\s*(\d+)\s*;/g, 'sid:$1;');
        console.log('Rule sau khi s·ª≠a ƒë·ªãnh d·∫°ng SID:', ruleStringModified);

        const sidMatch = ruleStringModified.match(/sid:\s*(\d+)\s*;/); // Tr√≠ch xu·∫•t SID sau khi s·ª≠a ƒë·ªãnh d·∫°ng
        const msgMatch = optionsPart.match(/msg:\s*"([^"]*)"\s*;/);  // Tr√≠ch xu·∫•t MSG, bao g·ªìm c·∫£ d·∫•u ngo·∫∑c ƒë∆°n
        const severityMatch = optionsPart.match(/signature_severity\s*(\S+)\s*;/); // Tr√≠ch xu·∫•t signature_severity n·∫øu c√≥

        // Log ƒë·ªÉ ki·ªÉm tra ph·∫ßn MSG
        // console.log('Chu·ªói optionsPart:', optionsPart);  // Debug chu·ªói options
        // console.log('K·∫øt qu·∫£ c·ªßa ph√©p match SID:', sidMatch ? sidMatch[1] : 'Kh√¥ng t√¨m th·∫•y SID');
        // console.log('K·∫øt qu·∫£ c·ªßa ph√©p match MSG:', msgMatch ? msgMatch[1] : 'Kh√¥ng t√¨m th·∫•y MSG');

        return {
            sid: sidMatch ? sidMatch[1] : 'Unknown', // Tr√≠ch xu·∫•t SID, l·∫•y gi√° tr·ªã n·∫øu c√≥
            msg: msgMatch ? msgMatch[1] : 'Unknown', // Tr√≠ch xu·∫•t MSG, b·ªè d·∫•u ngo·∫∑c k√©p
            action: action || 'Unknown', // Tr√≠ch xu·∫•t action
            protocol: actionParts[1] || 'Unknown', // Tr∆∞·ªùng th·ª© 2 l√† Protocol
            src: actionParts[2] + ' ' + actionParts[3] || 'Unknown', // Tr√≠ch xu·∫•t Source
            dst: actionParts[5] + ' ' + actionParts[6] || 'Unknown', // Tr√≠ch xu·∫•t Destination
            severity: severityMatch ? severityMatch[1] : 'Unknown' // Tr√≠ch xu·∫•t Severity t·ª´ signature_severity
        };
    } catch (error) {
        console.error('Error parsing rule:', error.message);
        throw new Error('L·ªói khi ph√¢n t√≠ch c√∫ ph√°p rule');
    }
}

//============================================================================================================================//
// Route ƒë·ªÉ l·∫•y th√¥ng tin l·∫ßn c·∫≠p nh·∫≠t rules cu·ªëi c√πng 
app.get('/api/rules/lastUpdate',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        const count = await executeCommand(address, 'root', pass, 'stat -c %y /etc/suricata/all_rules.rules | cut -d" " -f1');
        res.json({ count });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//============================================================================================================================//
// Route ƒë·ªÉ l·∫•y phi√™n b·∫£n c·ª•c b·ªô
app.get('/api/rules/localVersion',  async (req, res) => {
    const { address, pass } = req.session.sshInfo;

    try {
        let version = await executeCommand(address, 'root', pass, 'cat /etc/suricata/rules/version.txt');
        version = version.trim(); // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng d∆∞ th·ª´a
        if (version.startsWith('#version:')) {
            version = version.replace('#version:', ''); // Lo·∫°i b·ªè ti·ªÅn t·ªë '#version:'
        }
        res.json({ version });
    } catch (error) {
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});



//============================================================================================================================//
// Route ƒë·ªÉ tr·∫£ v·ªÅ danh s√°ch c√°c file rule
app.get('/api/rules/list',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin t·ª´ session

    try {
        const command = 'ls /etc/suricata/rules'; // L·ªánh ƒë·ªÉ l·∫•y danh s√°ch file
        const result = await executeCommand(address, 'root', pass, command); // Th·ª±c thi l·ªánh
        const files = result.split('\n').filter(file => file.trim() !== ''); // L·ªçc b·ªè d√≤ng tr·ªëng
        res.json({ files }); // Tr·∫£ v·ªÅ danh s√°ch file d∆∞·ªõi d·∫°ng JSON
    } catch (error) {
        res.status(500).json({ message: 'Error fetching rule list', error: error.message });
    }
});

//=============================================================================================================================//
// Route ƒë·ªÉ t·∫£i n·ªôi dung file /etc/suricata/suricata.yaml
//============================================================================================================================//
// Route ƒë·ªÉ l·∫•y n·ªôi dung file
app.get('/api/file/:fileName',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session
    const { fileName } = req.params;
    
    const fileMap = {
        suricata: '/etc/suricata/suricata.yaml',
        classification: '/etc/suricata/classification.config',
        threshold: '/etc/suricata/threshold.config',
        filebeat: '/etc/filebeat/filebeat.yaml'
    };

    const filePath = fileMap[fileName]; // L·∫•y ƒë∆∞·ªùng d·∫´n c·ªßa file t∆∞∆°ng ·ª©ng

    if (!filePath) {
        return res.status(404).json({ message: 'File kh√¥ng t·ªìn t·∫°i' });
    }

    try {
        // L·ªánh ƒë·ªÉ l·∫•y n·ªôi dung file
        const command = `cat ${filePath}`;
        const content = await executeCommand(address, 'root', pass, command); // Th·ª±c thi l·ªánh cat
        res.send(content); // Tr·∫£ v·ªÅ n·ªôi dung file
    } catch (error) {
        res.status(500).json({ message: 'L·ªói khi l·∫•y n·ªôi dung file', error: error.message });
    }
});

//============================================================================================================================//
//============================================================================================================================//
// Route ƒë·ªÉ l∆∞u n·ªôi dung file
app.post('/api/file/:fileName',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session
    const { fileName } = req.params;
    const { content } = req.body; // L·∫•y n·ªôi dung t·ª´ body request

    const fileMap = {
        suricata: '/etc/suricata/suricata.yaml',
        classification: '/etc/suricata/classification.config',
        threshold: '/etc/suricata/threshold.config',
        filebeat: '/etc/filebeat/filebeat.yml'
    };

    const filePath = fileMap[fileName]; // L·∫•y ƒë∆∞·ªùng d·∫´n file

    if (!filePath) {
        return res.status(404).json({ message: 'File kh√¥ng t·ªìn t·∫°i' });
    }

    try {
        // L·ªánh ƒë·ªÉ ghi n·ªôi dung m·ªõi v√†o file
        const command = `echo '${content.replace(/'/g, "'\\''")}' > ${filePath}`;
        await executeCommand(address, 'root', pass, command); // Th·ª±c thi l·ªánh echo ƒë·ªÉ ghi file

        // Th·ª±c thi script reload Suricata sau khi ghi file
        const reloadCommand = '/usr/local/etc/chowebApp/restart_suricata.sh';
        const reloadResult = await executeCommand(address, 'root', pass, reloadCommand); // Ch·∫°y script reload Suricata

        if (reloadResult.includes('<Error>')) {
            // N·∫øu c√≥ l·ªói, tr·∫£ v·ªÅ to√†n b·ªô th√¥ng b√°o l·ªói
            const errors = reloadResult.split('\n').filter(line => line.includes('<Error>'));
            return res.json({ success: false, errors });
        }

        res.json({ success: true, message: 'L∆∞u file v√† reload d·ªãch v·ª• Suricata th√†nh c√¥ng' });
    } catch (error) {
        res.status(500).json({ message: 'L·ªói khi l∆∞u file ho·∫∑c reload Suricata', error: error.message });
    }
});

//============================================================================================================================//
// Route ƒë·ªÉ l·∫•y n·ªôi dung file t·ª´ thi·∫øt b·ªã t·ª´ xa
app.get('/api/rules/file/:fileName',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session
    const { fileName } = req.params;

    try {
        // X√°c th·ª±c t√™n file h·ª£p l·ªá
        if (!fileName.endsWith('.rules')) {
            return res.status(400).json({ message: 'T√™n file kh√¥ng h·ª£p l·ªá' });
        }

        // Th·ª±c thi l·ªánh SSH ƒë·ªÉ ƒë·ªçc n·ªôi dung file
        const command = `cat /etc/suricata/rules/${fileName}`;
        const fileContent = await executeCommand(address, 'root', pass, command);

        // Tr·∫£ v·ªÅ n·ªôi dung file
        res.json({ success: true, content: fileContent });
    } catch (error) {
        console.error('Error fetching file content:', error);
        res.status(500).json({ message: 'Kh√¥ng th·ªÉ l·∫•y n·ªôi dung file', error: error.message });
    }
});

// Route ƒë·ªÉ l∆∞u n·ªôi dung ch·ªânh s·ª≠a file
// Route ƒë·ªÉ l∆∞u n·ªôi dung ch·ªânh s·ª≠a file

app.post('/api/rules/file/:fileName',  async (req, res) => {
    const { address, pass } = req.session.sshInfo;
    const { fileName } = req.params;
    const { changes, fullFileContent } = req.body;

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!changes || changes.length === 0) {
        return res.status(400).json({
            success: false,
            message: 'Kh√¥ng c√≥ thay ƒë·ªïi n√†o ƒë·ªÉ l∆∞u',
        });
    }

    if (!fullFileContent || typeof fullFileContent !== 'string') {
        return res.status(400).json({
            success: false,
            message: 'D·ªØ li·ªáu to√†n b·ªô file kh√¥ng h·ª£p l·ªá',
        });
    }

    try {
        const tempFilePath = '/tmp/fixrules.rules';
        const fullTempFilePath = '/tmp/fullrules.rules';
        const tempContent = changes.map(change => change.content).join("\n");

        // Ghi ch·ªâ nh·ªØng d√≤ng thay ƒë·ªïi v√†o file t·∫°m
        const saveTempRuleCommand = `echo '${tempContent.replace(/'/g, "'\\''")}' > ${tempFilePath}`;
        await executeCommand(address, 'root', pass, saveTempRuleCommand);

        // Ghi to√†n b·ªô n·ªôi dung file m·ªõi v√†o file t·∫°m ch·ª©a to√†n b·ªô n·ªôi dung
        const saveFullRuleCommand = `echo '${fullFileContent.replace(/'/g, "'\\''")}' > ${fullTempFilePath}`;
        await executeCommand(address, 'root', pass, saveFullRuleCommand);

        // Ki·ªÉm tra file t·∫°m v·ªõi script ki·ªÉm tra rules
        const checkTempRuleCommand = `/usr/local/etc/chowebApp/kiemtrarule.sh ${tempFilePath}`;
        const checkResult = await executeCommand(address, 'root', pass, checkTempRuleCommand);

        if (checkResult.includes('T·ªïng s·ªë rule sai: 0')) {
            console.log('[INFO] Ki·ªÉm tra th√†nh c√¥ng, chu·∫©n b·ªã ghi ƒë√® file g·ªëc.');

            // Di chuy·ªÉn file t·∫°m ch·ª©a to√†n b·ªô n·ªôi dung th√†nh file g·ªëc
            const originalFilePath = `/etc/suricata/rules/${fileName}`;
            const moveFullRuleCommand = `mv ${fullTempFilePath} ${originalFilePath}`;
            await executeCommand(address, 'root', pass, moveFullRuleCommand);

            // Kh·ªüi ƒë·ªông l·∫°i d·ªãch v·ª•
            const restartCommand = `/usr/local/etc/chowebApp/restart_suricata.sh`;
            await executeCommand(address, 'root', pass, restartCommand);

            return res.json({
                success: true,
                message: 'S·ª≠a rule th√†nh c√¥ng',
            });
        } else {
            const errorLines = checkResult.split('\n').filter(line => 
                line.includes('T·ªïng s·ªë rule sai') || 
                line.includes('N·ªôi dung rule ƒë·∫ßy ƒë·ªß') || 
                line.includes('V·ªã tr√≠:')
            );
            return res.status(400).json({
                success: false,
                message: 'C√≥ l·ªói trong rule',
                errors: errorLines,
            });
        }
    } catch (error) {
        console.error('[ERROR] Error updating rule:', error.message);
        return res.status(500).json({
            success: false,
            message: 'L·ªói khi l∆∞u file ho·∫∑c reload Suricata',
            error: error.message,
        });
    }
});



//============================================================================================================================//
// Route ƒë·ªÉ ki·ªÉm tra c·∫≠p nh·∫≠t rule t·ª´ URL so v·ªõi t·ªáp c·ª•c b·ªô
app.post('/api/check-update',  async (req, res) => {
    const { address, pass } = req.session.sshInfo;
    const { feedUrl } = req.body;

    try {
        // L·∫•y t√™n t·ªáp t·ª´ feedUrl ƒë·ªÉ t·∫°o ƒë∆∞·ªùng d·∫´n localFilePath ƒë·ªông
        const fileName = require('path').basename(feedUrl); // L·∫•y t√™n file t·ª´ URL, v√≠ d·ª• "trafficid.rules"
        const localFilePath = `/etc/suricata/rules/${fileName}`; // T·∫°o ƒë∆∞·ªùng d·∫´n localFilePath

        console.log(`So s√°nh t·ªáp local: ${localFilePath} v·ªõi feedUrl: ${feedUrl}`);

        const localFileContent = await executeCommand(address, 'root', pass, `cat ${localFilePath}`);







        const response = await fetch(feedUrl);
        if (!response.ok) {
            throw new Error(`Kh√¥ng th·ªÉ t·∫£i n·ªôi dung t·ª´ feedUrl: ${response.statusText}`);
        }
        const remoteFileContent = await response.text();

        // T√≠nh gi√° tr·ªã bƒÉm c·ªßa n·ªôi dung local v√† remote
        const localHash = crypto.createHash('sha256').update(localFileContent).digest('hex');
        const remoteHash = crypto.createHash('sha256').update(remoteFileContent).digest('hex');

        if (localHash === remoteHash) {
            // N·∫øu gi√° tr·ªã bƒÉm gi·ªëng nhau, kh√¥ng c·∫ßn so s√°nh chi ti·∫øt
            return res.json({ updateAvailable: false });
        }

        const localLines = localFileContent.split('\n').filter(line => line.includes('sid'));
        const remoteLines = remoteFileContent.split('\n').filter(line => line.includes('sid'));
        const localSids = {};
        const differences = {
            newRules: [],
            modifiedRules: []
        };

        // T·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ l∆∞u c√°c sid t·ª´ file local
        localLines.forEach(line => {
            const sidMatch = line.match(/sid:\s*(\d+)/);
            if (sidMatch) {
                localSids[sidMatch[1]] = line.trim();
            }
        });

        // So s√°nh c√°c d√≤ng t·ª´ remote
        remoteLines.forEach(line => {
            const sidMatch = line.match(/sid:\s*(\d+)/);
            if (sidMatch) {
                const remoteSid = sidMatch[1];
                const remoteLine = line.trim();

                if (!localSids[remoteSid]) {
                    // D√≤ng c√≥ "sid" tr√™n remote nh∆∞ng kh√¥ng c√≥ tr√™n local -> Rule m·ªõi
                    differences.newRules.push({
                        sid: remoteSid,
                        remote: remoteLine
                    });
                } else if (localSids[remoteSid] !== remoteLine) {
                    // N·∫øu "sid" t·ªìn t·∫°i trong c·∫£ hai file nh∆∞ng kh√°c nhau
                    const localLine = localSids[remoteSid];
                    const localParts = localLine.split(/\s+/);
                    const remoteParts = remoteLine.split(/\s+/);
                    const diffParts = [];

                    localParts.forEach((part, index) => {
                        if (part !== remoteParts[index]) {
                            diffParts.push(`<span class=\"highlight\">${remoteParts[index]}</span>`);
                        } else {
                            diffParts.push(part);
                        }
                    });

                    differences.modifiedRules.push({
                        sid: remoteSid,
                        local: localLine,
                        remote: diffParts.join(' ')
                    });
                }

                // X√≥a sid ƒë√£ x·ª≠ l√Ω ƒë·ªÉ kh√¥ng so s√°nh l·∫°i
                delete localSids[remoteSid];
            }
        });

        // Ki·ªÉm tra n·∫øu c√≤n c√°c d√≤ng "sid" trong local m√† kh√¥ng c√≥ trong remote (n·∫øu c·∫ßn thi·∫øt)
        Object.keys(localSids).forEach(sid => {
            differences.modifiedRules.push({
                sid: sid,
                local: localSids[sid],
                remote: 'Kh√¥ng t·ªìn t·∫°i trong t·ªáp t·ª´ URL'
            });
        });

        if (differences.newRules.length === 0 && differences.modifiedRules.length === 0) {
            res.json({ updateAvailable: false });
        } else {
            res.json({ updateAvailable: true, differences });
        }
    } catch (error) {
        console.error('L·ªói khi ki·ªÉm tra c·∫≠p nh·∫≠t:', error);
        res.status(500).json({ message: 'L·ªói khi ki·ªÉm tra c·∫≠p nh·∫≠t', error: error.message });
    }
});




//============================================================================================================================//
// Route ƒë·ªÉ t·∫£i file t·ª´ feedUrl v·ªÅ m√°y host

// API t·∫£i file
// API t·∫£i file
app.post('/api/tairule', async (req, res) => {
    const { url } = req.body; // URL ƒë∆∞·ª£c g·ª≠i t·ª´ client
  
    if (!url) {
      return res.status(400).json({ error: 'URL kh√¥ng h·ª£p l·ªá!' });
    }
  
    try {
      // T√°ch t√™n file t·ª´ URL
      const fileName = url.split('/').pop();
  
      // G·ª≠i request t·∫£i file t·ª´ URL
      const response = await axios({
        method: 'get',
        url: url,
        responseType: 'stream',
      });
  
      // G·∫Øn header Content-Type t·ª´ response c·ªßa axios
      const contentType = response.headers['content-type'] || 'application/octet-stream';
      res.setHeader('Content-Disposition', `attachment; filename=${fileName}`);
      res.setHeader('Content-Type', contentType);
  
      // Truy·ªÅn d·ªØ li·ªáu t·ª´ stream c·ªßa axios ƒë·∫øn response
      response.data.pipe(res);
    } catch (error) {
      console.error('L·ªói t·∫£i file:', error.message);
      res.status(500).json({ error: 'Kh√¥ng th·ªÉ t·∫£i file!' });
    }
  });
  
// Route ƒë·ªÉ t·∫£i file t·ª´ feedUrl v√† g·ª≠i v·ªÅ tr√¨nh duy·ªát
// Route ƒë·ªÉ t·∫£i t·∫•t c·∫£ c√°c b·∫£n c·∫≠p nh·∫≠t
// Route t·∫£i file t·ª´ feedUrl v√† g·ª≠i v·ªÅ tr√¨nh duy·ªát
// Danh s√°ch c√°c URL cho c√°c b·∫£n c·∫≠p nh·∫≠t
// Danh s√°ch c√°c URL cho c√°c b·∫£n c·∫≠p nh·∫≠t
const downloadUrls = {
    downloadUpdate1: "https://rules.emergingthreats.net/open/old/suricata-4.0/emerging.rules.tar.gz",
    downloadUpdate2: "https://rules.ptsecurity.com/files/ptopen.rules.tar.gz",
    downloadUpdate3: "https://example.com/some-other-file.rules",
    // B·∫°n c√≥ th·ªÉ th√™m nhi·ªÅu URL ·ªü ƒë√¢y cho c√°c tr∆∞·ªùng h·ª£p kh√°c
};

// Route t·∫£i file t·ª´ feedUrl v√† g·ª≠i v·ªÅ tr√¨nh duy·ªát
app.post('/api/download-update', async (req, res) => {
    const { updateKey } = req.body; // Nh·∫≠n key cho b·∫£n c·∫≠p nh·∫≠t (v√≠ d·ª•: downloadUpdate1, downloadUpdate2)

    // Ki·ªÉm tra n·∫øu updateKey kh√¥ng h·ª£p l·ªá
    if (!downloadUrls[updateKey]) {
        return res.status(400).send('Invalid update key');
    }

    const feedUrl = downloadUrls[updateKey]; // L·∫•y URL t·ª´ danh s√°ch
    try {
        const response = await fetch(feedUrl);
        if (!response.ok) {
            throw new Error(`Kh√¥ng th·ªÉ t·∫£i file t·ª´ URL: ${response.statusText}`);
        }

        const fileContent = await response.buffer(); // S·ª≠ d·ª•ng buffer ƒë·ªÉ t·∫£i file nh·ªã ph√¢n

        // Tr√≠ch xu·∫•t t√™n file t·ª´ URL
        const fileName = path.basename(feedUrl); // L·∫•y ph·∫ßn t√™n file t·ª´ URL (v√≠ d·ª•: "emerging.rules.tar.gz")

        // Tr·∫£ file v·ªÅ tr√¨nh duy·ªát v·ªõi header t·∫£i xu·ªëng
        res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
        res.setHeader('Content-Type', 'application/octet-stream'); // Lo·∫°i MIME ph√π h·ª£p cho file nh·ªã ph√¢n
        res.send(fileContent); // G·ª≠i n·ªôi dung file v·ªÅ ph√≠a client
    } catch (error) {
        console.error('L·ªói khi t·∫£i file v·ªÅ tr√¨nh duy·ªát:', error);
        res.status(500).json({ message: 'L·ªói khi t·∫£i file v·ªÅ', error: error.message });
    }
});







function parseRules(content) {
    const lines = content.split('\n').filter(line => line.trim());
    const rules = {};

    lines.forEach(line => {
        const sidMatch = line.match(/sid:\s*(\d+);/);
        if (sidMatch) {
            const sid = sidMatch[1];
            const revMatch = line.match(/rev:\s*(\d+);/);
            const rev = revMatch ? parseInt(revMatch[1], 10) : 0;
            rules[sid] = { line, rev };
        }
    });

    return rules;
}

function mergeRules(localRules, importedRules) {
    const mergedRules = { ...localRules };

    Object.keys(importedRules).forEach(sid => {
        if (!localRules[sid]) {
            // N·∫øu SID ch∆∞a t·ªìn t·∫°i trong local, th√™m m·ªõi
            mergedRules[sid] = importedRules[sid];
        } else if (importedRules[sid].rev > localRules[sid].rev) {
            // N·∫øu SID t·ªìn t·∫°i v√† REV m·ªõi h∆°n, ghi ƒë√®
            mergedRules[sid] = importedRules[sid];
        }
    });

    // Tr·∫£ v·ªÅ danh s√°ch c√°c rule ƒë√£ h·ª£p nh·∫•t
    return Object.values(mergedRules).map(rule => rule.line);
}



// C·∫•u h√¨nh Multer
const upload = multer({
    limits: {
        fileSize: 50 * 1024 * 1024 // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc m·ªói t·ªáp l√† 50MB
    }
});

// API ƒë·ªÉ t·∫£i file l√™n thi·∫øt b·ªã t·ª´ xa
// API ƒë·ªÉ t·∫£i file l√™n thi·∫øt b·ªã t·ª´ xa
// API ƒë·ªÉ t·∫£i file l√™n thi·∫øt b·ªã t·ª´ xa
app.post('/api/uploadFiles', upload.array('file'), async (req, res) => {
    const { address, pass } = req.session.sshInfo;
    const files = req.files;

    // Ki·ªÉm tra xem c√≥ file n√†o ƒë∆∞·ª£c g·ª≠i l√™n hay kh√¥ng
    if (!files || files.length === 0) {
        return res.status(400).json({ success: false, message: 'Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn' });
    }

    const conn = new Client();
    conn.on('ready', async () => {
        try {
            conn.sftp((err, sftp) => {
                if (err) {
                    return res.status(500).json({ success: false, message: 'L·ªói khi k·∫øt n·ªëi SFTP', error: err.message });
                }

                // Upload t·∫•t c·∫£ file
                Promise.all(files.map(file => {
                    return new Promise((resolve, reject) => {
                        const remotePath = `/etc/suricata/rules/${file.originalname}`;
                        const writeStream = sftp.createWriteStream(remotePath);

                        writeStream.on('close', resolve);
                        writeStream.on('error', reject);

                        writeStream.write(file.buffer);
                        writeStream.end();
                    });
                }))
                .then(async () => {
                    // Sau khi t·∫£i file th√†nh c√¥ng, th·ª±c thi c·∫≠p nh·∫≠t version ngay trong API n√†y
                    try {
                        // L·∫•y phi√™n b·∫£n t·ª´ xa
                        const remoteResponse = await fetch('https://rules.emergingthreats.net/open/suricata-4.0/version.txt');
                        
                        if (!remoteResponse.ok) {
                            throw new Error(`Failed to fetch remote version, status: ${remoteResponse.status}`);
                        }

                        // ƒê·ªçc phi√™n b·∫£n t·ª´ xa v√† lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
                        let remoteVersion = (await remoteResponse.text()).trim();

                        // Lo·∫°i b·ªè ti·ªÅn t·ªë '#version:' n·∫øu c√≥
                        if (remoteVersion.startsWith('#version:')) {
                            remoteVersion = remoteVersion.replace('#version:', '');
                        }

                        // ƒê∆∞·ªùng d·∫´n t·ªáp phi√™n b·∫£n c·ª•c b·ªô
                        const localVersionPath = '/etc/suricata/rules/version.txt';
                        const localVersion = fs.existsSync(localVersionPath) ? fs.readFileSync(localVersionPath, 'utf8').trim() : '';

                        console.log(localVersion);
                        console.log(remoteVersion);

                        // So s√°nh c√°c phi√™n b·∫£n
                        if (compareVersions(remoteVersion, localVersion) > 0) {
                            // C·∫≠p nh·∫≠t phi√™n b·∫£n c·ª•c b·ªô v·ªõi phi√™n b·∫£n t·ª´ xa
                            const command = `echo '${remoteVersion.replace(/'/g, "'\\''")}' > ${localVersionPath}`;
                            await executeCommand(address, 'root', pass, command); // Ghi ƒë√® t·ªáp version.txt v·ªõi phi√™n b·∫£n t·ª´ xa

                            console.log('Phi√™n b·∫£n ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng');
                        } else {
                            console.log('Phi√™n b·∫£n c·ª•c b·ªô ƒë√£ l√† phi√™n b·∫£n m·ªõi nh·∫•t');
                        }
                    } catch (error) {
                        console.error('L·ªói khi c·∫≠p nh·∫≠t phi√™n b·∫£n c·ª•c b·ªô:', error.message);
                    }

                    conn.end();
                    res.json({ success: true, message: 'C·∫≠p nh·∫≠t th√†nh c√¥ng' });

                    const restartafterupdate = `/usr/local/etc/chowebApp/restart_suricata.sh`;
                    await executeCommand(address, 'root', pass, restartafterupdate);
                })
                .catch(error => {
                    conn.end();
                    res.status(500).json({ success: false, message: 'L·ªói khi t·∫£i file l√™n thi·∫øt b·ªã', error: error.message });
                });
            });
        } catch (error) {
            conn.end();
            res.status(500).json({ success: false, message: 'L·ªói khi t·∫£i file l√™n thi·∫øt b·ªã', error: error.message });
        }
    }).connect({
        host: address,
        port: 22,
        username: 'root',
        password: pass,
    });
});

// H√†m so s√°nh hai phi√™n b·∫£n (so s√°nh c√°c chu·ªói phi√™n b·∫£n theo ƒë·ªãnh d·∫°ng x.y.z)
function compareVersions(version1, version2) {
    const v1Parts = version1.split('.').map(Number);
    const v2Parts = version2.split('.').map(Number);

    // So s√°nh t·ª´ng ph·∫ßn trong phi√™n b·∫£n
    for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
        const part1 = v1Parts[i] || 0; // Ph·∫ßn thi·∫øu m·∫∑c ƒë·ªãnh l√† 0
        const part2 = v2Parts[i] || 0; // Ph·∫ßn thi·∫øu m·∫∑c ƒë·ªãnh l√† 0

        if (part1 > part2) return 1; // version1 l·ªõn h∆°n version2
        if (part1 < part2) return -1; // version1 nh·ªè h∆°n version2
    }
    return 0; // C√°c phi√™n b·∫£n b·∫±ng nhau
}



// API ƒë·ªÉ t·∫£i file l√™n thi·∫øt b·ªã t·ª´ xa
app.post('/api/uploadFilesPT', upload.array('file'), async (req, res) => {
    const { address, pass } = req.session.sshInfo;
    const files = req.files;

    // Ki·ªÉm tra xem c√≥ file n√†o ƒë∆∞·ª£c g·ª≠i l√™n hay kh√¥ng
    if (!files || files.length === 0) {
        return res.status(400).json({ success: false, message: 'Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn' });
    }

    const conn = new Client();
    conn.on('ready', async () => {
        try {
            conn.sftp((err, sftp) => {
                if (err) {
                    return res.status(500).json({ success: false, message: 'L·ªói khi k·∫øt n·ªëi SFTP', error: err.message });
                }

                // Upload t·∫•t c·∫£ file
                Promise.all(files.map(file => {
                    return new Promise((resolve, reject) => {
                        const remotePath = `/etc/suricata/rules/${file.originalname}`;
                        const writeStream = sftp.createWriteStream(remotePath);

                        writeStream.on('close', resolve);
                        writeStream.on('error', reject);

                        writeStream.write(file.buffer);
                        writeStream.end();
                    });
                }))
                .then(async () => {
                    // Sau khi t·∫£i file th√†nh c√¥ng, th·ª±c thi c·∫≠p nh·∫≠t version ngay trong API n√†y
                    try {
                        // Th·ª±c thi script c·∫≠p nh·∫≠t
                        const updateScript = `/usr/local/etc/chowebApp/pt_update.sh`;
                        const updateResult = await executeCommand(address, 'root', pass, updateScript);
                        console.log('K·∫øt qu·∫£ script c·∫≠p nh·∫≠t:', updateResult);

                        // Kh·ªüi ƒë·ªông l·∫°i Suricata
                        const restartScript = `/usr/local/etc/chowebApp/restart_suricata.sh`;
                        const restartResult = await executeCommand(address, 'root', pass, restartScript);
                        console.log('K·∫øt qu·∫£ kh·ªüi ƒë·ªông l·∫°i Suricata:', restartResult);

                        conn.end();
                        res.json({ success: true, message: 'C·∫≠p nh·∫≠t th√†nh c√¥ng' });
                    } catch (error) {
                        conn.end();
                        console.error('L·ªói khi ch·∫°y script c·∫≠p nh·∫≠t:', error);
                        res.status(500).json({
                            success: false,
                            message: 'L·ªói khi ch·∫°y script c·∫≠p nh·∫≠t',
                            error: error.message || error.toString(),
                        });
                    }
                })

                .catch(error => {
                    conn.end();
                    res.status(500).json({ success: false, message: 'L·ªói khi t·∫£i file l√™n thi·∫øt b·ªã', error: error.message });
                });
            });
        } catch (error) {
            conn.end();
            res.status(500).json({ success: false, message: 'L·ªói khi t·∫£i file l√™n thi·∫øt b·ªã', error: error.message });
        }
    }).connect({
        host: address,
        port: 22,
        username: 'root',
        password: pass,
    });
});


// API ƒë·ªÉ t·∫£i file l√™n thi·∫øt b·ªã t·ª´ xa
app.post('/api/uploadExtensionRule', upload.array('file'), async (req, res) => {
    const { address, pass } = req.session.sshInfo || {};
    const files = req.files;

    if (!address || !pass) {
        return res.status(400).json({ success: false, message: 'Th√¥ng tin SSH kh√¥ng t·ªìn t·∫°i' });
    }

    if (!files || files.length === 0) {
        return res.status(400).json({ success: false, message: 'Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn' });
    }

    const conn = new Client();

    conn.on('ready', () => {
        try {
            conn.sftp((err, sftp) => {
                if (err) {
                    return res.status(500).json({ success: false, message: 'L·ªói khi k·∫øt n·ªëi SFTP', error: err.message });
                }

                const uploadPromises = files.map(file => {
                    return new Promise((resolve, reject) => {
                        const remotePath = `/etc/suricata/rules/${file.originalname}`;
                        const writeStream = sftp.createWriteStream(remotePath);

                        writeStream.on('close', () => resolve());
                        writeStream.on('error', reject);

                        writeStream.write(file.buffer);
                        writeStream.end();
                    });
                });

                Promise.all(uploadPromises)
                    .then(async () => {
                        try {
                            const restartScript = `/usr/local/etc/chowebApp/restart_suricata.sh`;
                            const restartResult = await executeCommand(address, 'root', pass, restartScript);
                            console.log('K·∫øt qu·∫£ kh·ªüi ƒë·ªông l·∫°i Suricata:', restartResult);

                            conn.end();
                            res.json({ success: true, message: 'C·∫≠p nh·∫≠t th√†nh c√¥ng' });
                        } catch (error) {
                            conn.end();
                            console.error('L·ªói khi ch·∫°y script c·∫≠p nh·∫≠t:', error);
                            res.status(500).json({ success: false, message: 'L·ªói khi ch·∫°y script c·∫≠p nh·∫≠t', error: error.message });
                        }
                    })
                    .catch(error => {
                        conn.end();
                        console.error('L·ªói khi t·∫£i file l√™n thi·∫øt b·ªã:', error);
                        res.status(500).json({ success: false, message: 'L·ªói khi t·∫£i file l√™n thi·∫øt b·ªã', error: error.message });
                    });
            });
        } catch (error) {
            conn.end();
            console.error('L·ªói khi x·ª≠ l√Ω k·∫øt n·ªëi SFTP:', error);
            res.status(500).json({ success: false, message: 'L·ªói x·ª≠ l√Ω k·∫øt n·ªëi SFTP', error: error.message });
        }
    }).connect({
        host: address,
        port: 22,
        username: 'root',
        password: pass,
    });

    conn.on('error', error => {
        console.error('L·ªói k·∫øt n·ªëi SSH:', error);
        res.status(500).json({ success: false, message: 'L·ªói k·∫øt n·ªëi SSH', error: error.message });
    });
});



// API ƒë·ªÉ c·∫≠p nh·∫≠t version.txt tr√™n thi·∫øt b·ªã t·ª´ xa
app.post('/api/update-version',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session

    try {
        // L·∫•y n·ªôi dung c·ªßa file version.txt t·ª´ URL
        const response = await fetch('https://rules.emergingthreats.net/open/suricata-4.0/version.txt');

        // Ki·ªÉm tra xem file c√≥ t·ªìn t·∫°i v√† tr·∫£ v·ªÅ n·ªôi dung hay kh√¥ng
        if (!response.ok) {
            throw new Error('Kh√¥ng th·ªÉ t·∫£i file version.txt t·ª´ URL');
        }


        console.log(response);

        const versionContent = await response.text(); // ƒê·ªçc n·ªôi dung file version.txt t·ª´ URL

        // L·ªánh ƒë·ªÉ ghi ƒë√® n·ªôi dung version.txt v√†o thi·∫øt b·ªã t·ª´ xa
        const command = `echo '${versionContent}' | sshpass -p ${pass} ssh user@${address} 'cat > /etc/suricata/rules/version.txt'`;

        // Th·ª±c thi l·ªánh SSH ƒë·ªÉ ghi ƒë√® v√†o version.txt
        await executeCommand(address, 'root', pass, command);

        res.json({ message: 'C·∫≠p nh·∫≠t version.txt th√†nh c√¥ng.' });
    } catch (error) {
        res.status(500).json({ message: 'L·ªói khi c·∫≠p nh·∫≠t version.txt.', error: error.message });
    }
});

//============================================================================================================================//
// Route ƒë·ªÉ b·∫≠t/t·∫Øt (Enable/Disable) t·ªáp rules
app.post('/api/rules/toggle',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session
    const { fileName, action } = req.body; // Nh·∫≠n d·ªØ li·ªáu t·ª´ request

    try {
        // L·ªánh ƒë·ªÉ g·ªçi script b·∫≠t/t·∫Øt rule qua SSH
        const command = `/usr/local/etc/chowebApp/suaconfig.sh "${action}" "${fileName}"`;
        console.log("Executing Command:", command); // Debug l·ªánh th·ª±c thi

        // S·ª≠ d·ª•ng executeCommand thay v√¨ exec
        const result = await executeCommand(address, 'root', pass, command);
        console.log("Command Output:", result); // Debug k·∫øt qu·∫£ l·ªánh

        // res.json({ message: `Thao t√°c ${action} th√†nh c√¥ng cho file ${fileName}.` });
        res.sendStatus(200);
    } catch (error) {
        console.error('Error executing command:', error); // Debug l·ªói n·∫øu c√≥
        res.status(500).json({ message: 'Error executing command', error: error.message });
    }
});

//============================================================================================================================//
// Route ƒë·ªÉ x·ª≠ l√Ω Enable/Disable file rules
// Route ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i c·ªßa file rules
// API ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i nhi·ªÅu rule
app.get('/api/rules/status',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session

    // Danh s√°ch c√°c rules c·∫ßn ki·ªÉm tra
    const rulesToCheck = [
        'trafficid.rules',
        'hunting.rules',
        'sslblacklist_tls_cert.rules',
        'sslipblacklist_aggressive.rules',
        'ja3_fingerprints.rules',
        'custom.rules'
    ];

    try {
        // T·∫°o l·ªánh ki·ªÉm tra tr·∫°ng th√°i c·ªßa t·∫•t c·∫£ c√°c rules
        const command = rulesToCheck
            .map(rule => `grep -E "^[[:space:]]*#[[:space:]]*-[[:space:]]*${rule}" /etc/suricata/suricata.yaml || echo "${rule}:Enable"`)
            .join(' && ');

        // Th·ª±c thi l·ªánh qua SSH
        const result = await executeCommand(address, 'root', pass, command);

        // Ph√¢n t√≠ch k·∫øt qu·∫£
        const statuses = {};
        rulesToCheck.forEach(rule => {
            const regex = new RegExp(`^.*${rule}.*$`, 'm');
            const match = result.match(regex);
            if (match) {
                statuses[rule] = match[0].startsWith('#') ? 'Disable' : 'Enable';
            } else {
                statuses[rule] = 'Unknown'; // N·∫øu kh√¥ng t√¨m th·∫•y d√≤ng
            }
        });

        res.json({ statuses });
    } catch (error) {
        res.status(500).json({ message: 'Error checking rule statuses', error: error.message });
    }
});

app.post('/api/rules/updateStatus',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session
    const { ruleName, enable } = req.body; // Nh·∫≠n t√™n rule v√† tr·∫°ng th√°i c·∫ßn c·∫≠p nh·∫≠t

    if (!ruleName) {
        return res.status(400).json({ message: 'Rule name is required.' });
    }

    try {
        // L·ªánh ƒë·ªÉ th√™m ho·∫∑c b·ªè # ƒë·∫ßu d√≤ng
        const updateCommand = enable
            ? `sed -i 's/^# - ${ruleName}/ - ${ruleName}/' /etc/suricata/suricata.yaml`
            : `sed -i 's/^ - ${ruleName}/# - ${ruleName}/' /etc/suricata/suricata.yaml`;

        // Th·ª±c thi l·ªánh SSH ƒë·ªÉ c·∫≠p nh·∫≠t file
        await executeCommand(address, 'root', pass, updateCommand);

        // Kh·ªüi ƒë·ªông l·∫°i Suricata
        const restartCommand = `/usr/local/etc/chowebApp/restart_suricata.sh`;
        await executeCommand(address, 'root', pass, restartCommand);

        res.json({ message: `Rule ${ruleName} updated successfully.` });
    } catch (error) {
        res.status(500).json({ message: `Error updating rule ${ruleName}.`, error: error.message });
    }
});








//============================================================================================================================//
// Bat dau check updtae
// Route ƒë·ªÉ ki·ªÉm tra phi√™n b·∫£n c·ªßa file local v√† remote
app.get('/api/check-updateET',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session
    const remoteVersionUrl = 'https://rules.emergingthreats.net/open/old/suricata-4.0/version.txt'; // URL c·ªßa phi√™n b·∫£n remote
    const localFilePath = '/etc/suricata/rules/version.txt'; // ƒê∆∞·ªùng d·∫´n t·ªõi file version.txt local

    try {
        // L·∫•y phi√™n b·∫£n t·ª´ file local
        const localVersion = await executeCommand(address, 'root', pass, `cat ${localFilePath}`);

        // L·∫•y n·ªôi dung phi√™n b·∫£n t·ª´ URL remote
        const response = await fetch(remoteVersionUrl);
        const remoteVersion = await response.text();

        // In ra k·∫øt qu·∫£ phi√™n b·∫£n local v√† remote ƒë·ªÉ debug
        console.log("Local Version:", localVersion.trim());
        console.log("Remote Version:", remoteVersion.trim());

        // So s√°nh phi√™n b·∫£n local v√† remote
        if (localVersion.trim() < remoteVersion.trim()) {
            res.json({
                updateAvailable: true,
                localVersion: localVersion.trim(),
                remoteVersion: remoteVersion.trim(),
            });
        } else if (localVersion.trim() === remoteVersion.trim()) {
            res.json({
                updateAvailable: false,
                localVersion: localVersion.trim(),
                remoteVersion: remoteVersion.trim(),
            });
        } else {
            res.status(400).json({
                message: 'Local version is newer than remote version',
                localVersion: localVersion.trim(),
                remoteVersion: remoteVersion.trim(),
            });
        }
    } catch (error) {
        // X·ª≠ l√Ω l·ªói
        res.status(500).json({
            message: 'Error checking update',
            error: error.message,
        });
    }
});


// API ƒë·ªÉ ki·ªÉm tra s·ª± kh√°c bi·ªát gi·ªØa file local v√† remote
// H√†m t√≠nh gi√° tr·ªã bƒÉm c·ªßa file
function getFileHash(fileContent) {
    return crypto.createHash('sha256').update(fileContent, 'utf8').digest('hex');
}

// H√†m l·ªçc ra c√°c d√≤ng ch·ª©a SID
function getSidLines(fileContent) {
    const lines = fileContent.split('\n');
    return lines.filter(line => line.includes('sid:'));
}

// H√†m so s√°nh c√°c d√≤ng c√≥ SID gi·ªëng nhau
function compareSidLines(localSidLines, remoteSidLines) {
    let differences = [];

    localSidLines.forEach(localLine => {
        const localSid = localLine.match(/sid:(\d+)/);
        if (localSid) {
            const remoteLine = remoteSidLines.find(remoteLine => remoteLine.includes(`sid:${localSid[1]}`));
            if (remoteLine) {
                // S·ª≠ d·ª•ng th∆∞ vi·ªán diff ƒë·ªÉ so s√°nh c√°c d√≤ng SID
                const lineDiff = diff.diffWords(localLine, remoteLine);
                const diffResult = lineDiff.filter(part => part.added || part.removed); // Ch·ªâ l·∫•y ph·∫ßn c√≥ s·ª± thay ƒë·ªïi

                if (diffResult.length > 0) {
                    // Ph√¢n bi·ªát r√µ s·ª± kh√°c bi·ªát gi·ªØa local v√† remote
                    const differenceDetail = diffResult.map(part => {
                        if (part.added) {
                            return `Remote: ${part.value}`;
                        } else if (part.removed) {
                            return `Local: ${part.value}`;
                        }
                        return ''; // Ph·∫ßn kh√¥ng c√≥ thay ƒë·ªïi kh√¥ng c·∫ßn hi·ªÉn th·ªã
                    }).join(' ');

                    differences.push({
                        SID: localSid[1],
                        local: localLine,
                        remote: remoteLine,
                        diff: differenceDetail.trim() // Ch·ªâ r√µ s·ª± kh√°c bi·ªát gi·ªØa Local v√† Remote
                    });
                }
            }
        }
    });

    return differences;
}


//=============================================================================================================================//


// API ƒë·ªÉ ki·ªÉm tra c·∫≠p nh·∫≠t PT
app.get('/api/check-updatePT',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // L·∫•y th√¥ng tin SSH t·ª´ session
    const scriptPath = '/usr/local/etc/chowebApp/pt.sh'; // ƒê∆∞·ªùng d·∫´n script tr√™n thi·∫øt b·ªã

    try {
        // Th·ª±c thi script tr√™n thi·∫øt b·ªã qua SSH
        const result = await executeCommand(address, 'root', pass, `sh ${scriptPath}`);

        // X·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ script
        const trimmedResult = result.trim();
        console.log("Script Output:", trimmedResult);

        if (trimmedResult === 'new') {
            res.json({ updateAvailable: true, message: 'C√≥ b·∫£n c·∫≠p nh·∫≠t m·ªõi' });
        } else if (trimmedResult === 'no') {
            res.json({ updateAvailable: false, message: 'Kh√¥ng c√≥ b·∫£n c·∫≠p nh·∫≠t m·ªõi' });
        } else {
            res.status(400).json({ message: 'Unexpected script output', output: trimmedResult });
        }
    } catch (error) {
        // X·ª≠ l√Ω l·ªói
        console.error("Error executing script:", error);
        res.status(500).json({ message: 'Error checking update', error: error.message });
    }
});


//=============================================================================================================================//
// Route ƒë·ªÉ l·∫•y danh s√°ch c√°c file .rules t·ª´ thi·∫øt b·ªã t·ª´ xa
app.get('/api/files',  async (req, res) => {
    const { address, pass } = req.session.sshInfo;

    // Danh s√°ch file c·∫ßn l·ªçc (ch·ªâ l·∫•y c√°c file n√†y)
    const allowedFiles = [
        "3coresec.rules",
        "botcc.portgrouped.rules",
        "botcc.rules",
        "ciarmy.rules",
        "compromised.rules",
        "dshield.rules",
        "drop.rules",
        "emerging-activex.rules",
        "emerging-attack_response.rules",
        "emerging-chat.rules",
        "emerging-current_events.rules",
        "emerging-deleted.rules",
        "emerging-dns.rules",
        "emerging-dos.rules",
        "emerging-exploit.rules",
        "emerging-ftp.rules",
        "emerging-games.rules",
        "emerging-icmp_info.rules",
        "emerging-icmp.rules",
        "emerging-imap.rules",
        "emerging-inappropriate.rules",
        "emerging-info.rules",
        "emerging-malware.rules",
        "emerging-misc.rules",
        "emerging-mobile_malware.rules",
        "emerging-netbios.rules",
        "emerging-p2p.rules",
        "emerging-policy.rules",
        "emerging-pop3.rules",
        "emerging-retired.rules",
        "emerging-rpc.rules",
        "emerging-scada.rules",
        "emerging-scan.rules",
        "emerging-shellcode.rules",
        "emerging-smtp.rules",
        "emerging-snmp.rules",
        "emerging-sql.rules",
        "emerging-telnet.rules",
        "emerging-tftp.rules",
        "emerging-trojan.rules",
        "emerging-user_agents.rules",
        "emerging-voip.rules",
        "emerging-web_client.rules",
        "emerging-web_server.rules",
        "emerging-web_specific_apps.rules",
        "emerging-worm.rules",
        "tor.rules"
    ];

    try {
        // L·∫•y danh s√°ch file .rules t·ª´ th∆∞ m·ª•c /etc/suricata/rules/
        const fileList = await executeCommand(address, 'root', pass, 'ls /etc/suricata/rules/*.rules');

        // Chuy·ªÉn danh s√°ch file t·ª´ string th√†nh m·∫£ng, l·ªçc theo danh s√°ch allowedFiles
        const ruleFiles = fileList.split('\n')
            .map(file => path.basename(file.trim()))  // L·∫•y t√™n file (b·ªè ƒë∆∞·ªùng d·∫´n)
            .filter(file => allowedFiles.includes(file));  // Ch·ªâ gi·ªØ l·∫°i file c√≥ trong danh s√°ch allowedFiles

        console.log("Danh s√°ch file sau khi l·ªçc:", ruleFiles);

        // Tr·∫£ v·ªÅ danh s√°ch file ƒë√£ l·ªçc
        res.json(ruleFiles);
    } catch (error) {
        console.error('Error fetching file list:', error);
        res.status(500).json({ message: 'Error fetching files', error: error.message });
    }
});




//=============================================================================================================================//
// Route ƒë·ªÉ so s√°nh file v·ªõi remote

function removeBlankLinesAtEdges(content) {
    // Lo·∫°i b·ªè c√°c d√≤ng tr·ªëng ·ªü ƒë·∫ßu v√† cu·ªëi n·ªôi dung
    return content.replace(/^\s*\n|\n\s*$/g, '');
}
app.get('/api/compare/:filename',  async (req, res) => {
    // console.log('SSH Info:', req.session.sshInfo);
    const { address, pass } = req.session.sshInfo;
    const filename = req.params.filename;

    const remoteFilePath = `/etc/suricata/rules/${filename}`;
    const remoteFileUrl = `https://rules.emergingthreats.net/open/old/suricata-4.0/rules/${filename}`;

    try {
        // ƒê·ªçc file t·ª´ thi·∫øt b·ªã t·ª´ xa
        const remoteFileContent = await executeCommand(address, 'root', pass, `cat ${remoteFilePath}`);
        if (!remoteFileContent) {
            throw new Error('Kh√¥ng th·ªÉ ƒë·ªçc file t·ª´ thi·∫øt b·ªã t·ª´ xa');
        }
        // console.log(`Fetched remote file content for ${filename}`);

        // T·∫£i file remote t·ª´ URL
        const remoteResponse = await fetch(remoteFileUrl);
        if (!remoteResponse.ok) {
            throw new Error(`Kh√¥ng th·ªÉ t·∫£i file t·ª´ URL: ${remoteFileUrl}`);
        }
        const remoteOnlineFileContent = await remoteResponse.text();
        // console.log(`Fetched online file content for ${filename}`);

         // Lo·∫°i b·ªè c√°c d√≤ng tr·ªëng ·ªü ƒë·∫ßu v√† cu·ªëi n·ªôi dung file
         const cleanedRemoteFileContent = removeBlankLinesAtEdges(remoteFileContent);
         const cleanedRemoteOnlineFileContent = removeBlankLinesAtEdges(remoteOnlineFileContent);

        // So s√°nh bƒÉm c·ªßa file remote
        // So s√°nh bƒÉm c·ªßa file remote
        const localFileHash = getFileHash(cleanedRemoteFileContent);
        const remoteFileHash = getFileHash(cleanedRemoteOnlineFileContent)

        if (localFileHash === remoteFileHash) {
            res.json({
                status: 'No change',
                message: 'Kh√¥ng c√≥ s·ª± thay ƒë·ªïi'
            });
        } else {
            // N·∫øu bƒÉm kh√°c nhau, ti·∫øn h√†nh so s√°nh n·ªôi dung
            const localSidLines = getSidLines(remoteFileContent); // D√≤ng ch·ª©a SID t·ª´ file local
            const remoteSidLines = getSidLines(remoteOnlineFileContent); // D√≤ng ch·ª©a SID t·ª´ file remote
            const differences = compareSidLines(localSidLines, remoteSidLines); //So s√°nh SID: N·∫øu c√°c gi√° tr·ªã trong hai d√≤ng ho√†n to√†n gi·ªëng nhau (ch·ªâ kh√°c nhau v·ªÅ kho·∫£ng tr·∫Øng), k·∫øt qu·∫£ so s√°nh s·∫Ω kh√¥ng ph√°t hi·ªán s·ª± kh√°c bi·ªát n√†o.

            res.json({
                status: differences.length > 0 ? 'Changed' : 'No SID differences',
                message: differences.length > 0 ? `C√≥ s·ª± thay ƒë·ªïi` : 'C√≥ s·ª± thay ƒë·ªïi nh∆∞ng kh√¥ng c√≥ kh√°c bi·ªát SID.',
                diff: differences
            });
        }
    } catch (error) {
        console.error('Error comparing files:', error);
        res.status(500).json({ status: 'error', message: 'Error comparing files', error: error.message });
    }
});



// API l·∫•y danh s√°ch rules
const statusFilePath = '/etc/suricata/rules/switchmode_data.txt'; // ƒê∆∞·ªùng d·∫´n file d·ªØ li·ªáu
const switchModeScript = '/usr/local/etc/chowebApp/switchmode.sh'; // ƒê∆∞·ªùng d·∫´n script

// API l·∫•y danh s√°ch rules
app.get('/api/switchmode/get-rules',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // Th√¥ng tin SSH
    const catCommand = `cat ${statusFilePath}`; // L·ªánh ƒë·ªçc file t·ª´ thi·∫øt b·ªã t·ª´ xa

    try {
        // 1. Ch·∫°y script ƒë·ªÉ c·∫≠p nh·∫≠t file switchmode_data.txt
        const runScriptCommand = `sh ${switchModeScript}`;
        await executeCommand(address, 'root', pass, runScriptCommand);

        // 2. ƒê·ªçc n·ªôi dung file switchmode_data.txt
        const result = await executeCommand(address, 'root', pass, catCommand);

        // 3. Parse d·ªØ li·ªáu t·ª´ file
        const rulesData = result
            .trim()
            .split('\n')
            .map((line) => {
                const parts = line.split(' '); // T√°ch d√≤ng theo d·∫•u c√°ch
                return {
                    name: parts[0], // T√™n rule
                    status: parts[1], // Tr·∫°ng th√°i hi·ªán t·∫°i
                    lastModified: parts.slice(2).join(' ') // Th·ªùi gian s·ª≠a ƒë·ªïi
                };
            });

        // 4. Tr·∫£ v·ªÅ d·ªØ li·ªáu JSON
        res.json(rulesData);
    } catch (error) {
        console.error('Error fetching rules:', error);
        res.status(500).json({ message: 'Error fetching rules', error: error.message });
    }
});


// API c·∫≠p nh·∫≠t tr·∫°ng th√°i rules
// API c·∫≠p nh·∫≠t tr·∫°ng th√°i rules
app.post('/api/switchmode/update-rules',  async (req, res) => {
    const { address, pass } = req.session.sshInfo; // Th√¥ng tin SSH
    const { rules } = req.body; // Danh s√°ch rules c·∫ßn c·∫≠p nh·∫≠t (d·∫°ng "name status")

    console.log('D·ªØ li·ªáu g·ª≠i l√™n:', rules); // Log d·ªØ li·ªáu t·ª´ client

    try {
        // ƒê·ªçc d·ªØ li·ªáu t·ª´ switchmode_data.txt tr∆∞·ªõc khi c·∫≠p nh·∫≠t
        const readCommand = `cat ${statusFilePath}`;
        const beforeUpdateData = await executeCommand(address, 'root', pass, readCommand);
        console.log('D·ªØ li·ªáu trong switchmode_data.txt (tr∆∞·ªõc khi c·∫≠p nh·∫≠t):\n', beforeUpdateData);

        // T·∫°o l·ªánh `sed` ƒë·ªÉ c·∫≠p nh·∫≠t t·ª´ng rule
        const updateCommands = rules.map((rule) => {
            const [name, status] = rule.split(' '); // T√°ch t√™n rule v√† tr·∫°ng th√°i
            const escapedName = name.replace(/(["`\\])/g, '\\$1'); // Escape t√™n rule
            // C·∫≠p nh·∫≠t duy nh·∫•t tr∆∞·ªùng th·ª© 2
            return `sed -i 's|^${escapedName} [^ ]*|${name} ${status}|' ${statusFilePath}`;
        }).join(' && ');

        // Th·ª±c thi l·ªánh c·∫≠p nh·∫≠t tr√™n thi·∫øt b·ªã t·ª´ xa
        console.log('Th·ª±c thi c·∫≠p nh·∫≠t...');
        await executeCommand(address, 'root', pass, updateCommands);

        // ƒê·ªçc d·ªØ li·ªáu sau khi c·∫≠p nh·∫≠t
        const afterUpdateData = await executeCommand(address, 'root', pass, readCommand);
        console.log('D·ªØ li·ªáu trong switchmode_data.txt (sau khi c·∫≠p nh·∫≠t):\n', afterUpdateData);

        // *** C·∫£i ti·∫øn: G·ªçi script Bash ƒë·ªÉ th·ª±c thi thay ƒë·ªïi ***
        const scriptArgs = rules.map((rule) => `"${rule}"`).join(' ');
        const executeScriptCommand = `/usr/local/etc/chowebApp/switchmode_update.sh ${scriptArgs}`;
        console.log('Th·ª±c thi script Bash v·ªõi l·ªánh:', executeScriptCommand);
        const scriptResult = await executeCommand(address, 'root', pass, executeScriptCommand);
        console.log('K·∫øt qu·∫£ t·ª´ script Bash:\n', scriptResult);

        // N·∫øu th√†nh c√¥ng, th·ª±c thi l·ªánh restart
        const restartCommand1 = `/usr/local/etc/chowebApp/restart_suricata.sh`;
        console.log('Th·ª±c thi restart Suricata v·ªõi l·ªánh:', restartCommand1);
        const restartResult1 = await executeCommand(address, 'root', pass, restartCommand1);
        console.log('K·∫øt qu·∫£ t·ª´ restart Suricata:\n', restartResult1);

        // Tr·∫£ v·ªÅ k·∫øt qu·∫£ th√†nh c√¥ng
        res.json({
            message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng',
            beforeUpdate: beforeUpdateData,
            afterUpdate: afterUpdateData,
            scriptOutput: scriptResult,
        });
    } catch (error) {
        console.error('Error updating rules:', error);
        res.status(500).json({ message: 'Error updating rules', error: error.message });
    }
});





//============================================================================================================================//
// API ƒë·ªÉ g·ªçi script addrule.sh
// L·∫•y th√¥ng tin MAC t·ª´ IP
app.post('/get-mac-info', (req, res) => {
    const ip = req.body.ip;

    if (!ip) {
        return res.status(400).json({ error: "Vui l√≤ng nh·∫≠p ƒë·ªãa ch·ªâ IP" });
    }

    // G·ªçi script Bash iptables_manager.sh v·ªõi IP
    exec(`bash ./script/addrule.sh ${ip}`, (err, stdout, stderr) => {
        if (err) {
            console.error('L·ªói khi th·ª±c thi script:', err);
            return res.status(500).json({ error: 'Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ MAC cho IP ƒë√£ nh·∫≠p!' });
        }

        if (stderr) {
            console.error('stderr:', stderr);
            return res.status(500).json({ error: 'C√≥ l·ªói x·∫£y ra trong khi th·ª±c thi script' });
        }

        try {
            const jsonData = JSON.parse(stdout.trim());
            res.json(jsonData);
        } catch (parseError) {
            console.error('L·ªói ph√¢n t√≠ch c√∫ ph√°p JSON:', parseError);
            return res.status(500).json({ error: 'L·ªói ph√¢n t√≠ch c√∫ ph√°p k·∫øt qu·∫£ t·ª´ script' });
        }
    });
});

// C·∫≠p nh·∫≠t tr·∫°ng th√°i MAC (ACCEPT/DROP)
app.post('/update-mac-status', (req, res) => {
    const { macAddress, action } = req.body;

    if (!macAddress || !action) {
        return res.status(400).json({ error: "Thi·∫øu ƒë·ªãa ch·ªâ MAC ho·∫∑c tr·∫°ng th√°i" });
    }

    // Ki·ªÉm tra action h·ª£p l·ªá
    if (action !== "ACCEPT" && action !== "DROP") {
        return res.status(400).json({ error: "H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá. Ch·ªâ ch·∫•p nh·∫≠n ACCEPT ho·∫∑c DROP" });
    }

    // G·ªçi script Bash iptables_manager.sh v·ªõi MAC v√† action
    exec(`bash ./script/addrule.sh ${macAddress} ${action}`, (err, stdout, stderr) => {
        if (err) {
            console.error('L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i:', err);
            return res.status(500).json({ error: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i' });
        }

        if (stderr) {
            console.error('stderr:', stderr);
            return res.status(500).json({ error: 'L·ªói x·∫£y ra khi c·∫≠p nh·∫≠t tr·∫°ng th√°i' });
        }

        try {
            const jsonData = JSON.parse(stdout.trim());
            res.json(jsonData);
        } catch (parseError) {
            console.error('L·ªói ph√¢n t√≠ch c√∫ ph√°p JSON:', parseError);
            return res.status(500).json({ error: 'L·ªói ph√¢n t√≠ch c√∫ ph√°p k·∫øt qu·∫£ t·ª´ script' });
        }
    });
});

// ƒê·∫£m b·∫£o b·∫°n ch·ªâ ƒë·ªãnh ƒë√∫ng th∆∞ m·ª•c ch·ª©a file script
// API l·∫•y top 4 domain v√† IP c√≥ l∆∞·ª£ng truy c·∫≠p cao nh·∫•t
app.post('/get-top-traffic', (req, res) => {
    exec(`bash ./script/traffic_stats.sh`, (err, stdout, stderr) => {
        if (err) {
            console.error('L·ªói khi l·∫•y d·ªØ li·ªáu th·ªëng k√™:', err);
            return res.status(500).json({ error: 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªëng k√™' });
        }

        if (stderr) {
            console.error('stderr:', stderr);
            return res.status(500).json({ error: 'L·ªói x·∫£y ra khi x·ª≠ l√Ω log' });
        }

        try {
            const jsonData = JSON.parse(stdout.trim());
            res.json(jsonData);
        } catch (parseError) {
            console.error('L·ªói ph√¢n t√≠ch JSON:', parseError);
            return res.status(500).json({ error: 'L·ªói x·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ script' });
        }
    });
});

// API ƒë·ªÉ l·∫•y th√¥ng tin ch·ªß s·ªü h·ªØu t·ª´ IP
// API ƒë·ªÉ l·∫•y th√¥ng tin ch·ªß s·ªü h·ªØu t·ª´ IP
app.post('/get-owner-from-ip', (req, res) => {
    const { ip } = req.body;

    if (!ip) {
        return res.status(400).json({ error: "Thi·∫øu ƒë·ªãa ch·ªâ IP" });
    }

    // G·ªçi script find-owner-from-ip.sh ƒë·ªÉ l·∫•y th√¥ng tin MAC v√† ch·ªß s·ªü h·ªØu t·ª´ IP
    exec(`bash ./script/find-owner-from-ip.sh ${ip}`, (err, stdout, stderr) => {
        if (err) {
            console.error('L·ªói khi t√¨m ch·ªß s·ªü h·ªØu:', err);
            return res.status(500).json({ error: 'Kh√¥ng th·ªÉ t√¨m ch·ªß s·ªü h·ªØu' });
        }

        if (stderr) {
            console.error('stderr:', stderr);
            return res.status(500).json({ error: 'L·ªói x·∫£y ra khi t√¨m ch·ªß s·ªü h·ªØu' });
        }

        try {
            const jsonData = JSON.parse(stdout.trim());
            res.json(jsonData);  // Tr·∫£ v·ªÅ th√¥ng tin ch·ªß s·ªü h·ªØu d∆∞·ªõi d·∫°ng JSON
        } catch (parseError) {
            console.error('L·ªói ph√¢n t√≠ch c√∫ ph√°p JSON:', parseError);
            return res.status(500).json({ error: 'L·ªói ph√¢n t√≠ch c√∫ ph√°p k·∫øt qu·∫£ t·ª´ script' });
        }
    });
});


app.post('/add-firewall-rule', (req, res) => {
    const { rule } = req.body;
    console.log("Received add-firewall-rule request:", req.body);

    if (!rule) {
        console.error("Missing rule parameter");
        return res.status(400).json({ error: "Missing rule parameter" });
    }
    
    // G·ªçi script add-iptables-rule.sh v·ªõi rule ƒë∆∞·ª£c truy·ªÅn v√†o
    const command = `bash ./script/add-iptables-rule.sh "${rule}"`;
    console.log("Executing command:", command);
    
    exec(command, (err, stdout, stderr) => {
        if (err) {
            console.error("Error executing add-iptables-rule.sh:", err);
            return res.status(500).json({ error: "Unable to add rule" });
        }
        
        if (stderr) {
            console.error("Script stderr:", stderr);
            // C√≥ th·ªÉ b·ªè qua stderr n·∫øu kh√¥ng quan tr·ªçng
        }
        
        console.log("Script stdout:", stdout);
        
        try {
            const result = JSON.parse(stdout.trim());
            res.json({ success: true, data: result });
        } catch (parseError) {
            console.error("JSON parsing error:", parseError);
            // N·∫øu kh√¥ng parse ƒë∆∞·ª£c, tr·∫£ v·ªÅ stdout th√¥
            return res.status(500).json({ error: "Error parsing script output", rawOutput: stdout.trim() });
        }
    });
});


// API ƒë·ªÉ l·∫•y thoong tin iptables
app.post('/get-firewall-from-table', (req, res) => {
    const { tableName } = req.body;

    if (!tableName) {
        // return res.status(400).json({ error: "Thi·∫øu t√™n b·∫£ng" });
        pass
    }

    // G·ªçi script getfirewall.sh ƒë·ªÉ l·∫•y th√¥ng tin t·ª´ b·∫£ng
    exec(`bash ./script/getfirewall.sh ${tableName}`, (err, stdout, stderr) => {
        if (err) {
            console.error('L·ªói khi l·∫•y th√¥ng tin firewall:', err);
            return res.status(500).json({ error: 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin firewall' });
        }

        if (stderr) {
            console.error('stderr:', stderr);
            // return res.status(500).json({ error: 'L·ªói x·∫£y ra khi l·∫•y th√¥ng tin firewall' });
        }

        try {
            const jsonData = JSON.parse(stdout.trim());
            res.json(jsonData);  // Tr·∫£ v·ªÅ th√¥ng tin firewall d∆∞·ªõi d·∫°ng JSON
        } catch (parseError) {
            console.error('L·ªói ph√¢n t√≠ch c√∫ ph√°p JSON:', parseError);
            return res.status(500).json({ error: 'L·ªói ph√¢n t√≠ch c√∫ ph√°p k·∫øt qu·∫£ t·ª´ script' });
        }
        console.log(`run end duyet`);
    });
});


// --- API: X√≥a rule iptables ---
// Endpoint nh·∫≠n { tableName, ruleIndexes } v√† g·ªçi script fixiptables.sh ƒë·ªÉ x√≥a rule.
app.post('/delete-firewall-rule', (req, res) => {
    const { tableName, ruleIndexes, chainName } = req.body;
    console.log("Received delete-firewall-rule request:", req.body);
  
    if (!tableName || !chainName || !ruleIndexes || !Array.isArray(ruleIndexes)) {
      console.error("Missing required parameters: tableName, chainName, or ruleIndexes");
      return res.status(400).json({ error: "Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt" });
    }
    
    // N·ªëi c√°c ruleIndexes th√†nh chu·ªói (m·ªói rule ƒë∆∞·ª£c ph√¢n c√°ch b·∫±ng kho·∫£ng tr·∫Øng)
    const indexes = ruleIndexes.join(' ');
    // X√¢y d·ª±ng l·ªánh g·ªçi script fixiptables.sh v·ªõi c√°c tham s·ªë: tableName, chainName v√† danh s√°ch ruleIndexes
    const command = `bash ./script/fixiptables.sh ${tableName} ${chainName} ${indexes}`;
    console.log("Executing command:", command);
    
    exec(command, (err, stdout, stderr) => {
      if (err) {
        console.error('Error executing fixiptables.sh:', err);
        return res.status(500).json({ error: 'Kh√¥ng th·ªÉ x√≥a rule' });
      }
      
      if (stderr) {
        console.error('Script stderr output:', stderr);
      }
      
      console.log('Script stdout output:', stdout);
      
      try {
        const result = JSON.parse(stdout.trim());
        console.log("Parsed result:", result);
        res.json({ success: true, data: result });
      } catch (parseError) {
        console.error('JSON parsing error:', parseError);
        return res.status(500).json({ error: 'L·ªói ph√¢n t√≠ch c√∫ ph√°p k·∫øt qu·∫£ t·ª´ script' });
      }
    });
  });
  


  // --- API: X√≥a rule iptables ---
  // Endpoint nh·∫≠n { tableName, ruleIndexes } v√† g·ªçi script fixiptables.sh ƒë·ªÉ x√≥a rule.
  app.post('/delete-firewall-rule', (req, res) => {
    const { tableName, ruleIndexes } = req.body;
    if (!tableName || !ruleIndexes || !Array.isArray(ruleIndexes)) {
      return res.status(400).json({ error: "Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt" });
    }
    
    // N·ªëi c√°c ruleIndexes th√†nh chu·ªói (m·ªói rule ƒë∆∞·ª£c ph√¢n c√°ch b·∫±ng kho·∫£ng tr·∫Øng)
    const indexes = ruleIndexes.join(' ');
    
    // G·ªçi script fixiptables.sh v·ªõi c√°c tham s·ªë: tableName v√† danh s√°ch rule indexes c·∫ßn x√≥a
    exec(`bash ./script/fixiptables.sh ${tableName} ${indexes}`, (err, stdout, stderr) => {
      if (err) {
        console.error('L·ªói khi x√≥a rule:', err);
        return res.status(500).json({ error: 'Kh√¥ng th·ªÉ x√≥a rule' });
      }
      if (stderr) {
        console.error('stderr:', stderr);
      }
      try {
        const result = JSON.parse(stdout.trim());
        res.json({ success: true, data: result });
      } catch (parseError) {
        console.error('L·ªói ph√¢n t√≠ch c√∫ ph√°p JSON:', parseError);
        return res.status(500).json({ error: 'L·ªói ph√¢n t√≠ch c√∫ ph√°p k·∫øt qu·∫£ t·ª´ script' });
      }
    });
  });




//tam chuan 
let cachedStaticLogData = {};  // B·ªô nh·ªõ t·∫°m ƒë·ªÉ l∆∞u c√°c t·ªáp log tƒ©nh

// L∆∞u ng√†y hi·ªán t·∫°i ƒë·ªÉ ki·ªÉm tra c√≥ ph·∫£i ng√†y m·ªõi kh√¥ng
let lastCheckedDate = null;

app.get('/get-log-from-pihole', async (req, res) => {
    const logFiles = ['pihole.log.3.gz', 'pihole.log.2.gz', 'pihole.log.1', 'pihole.log'];

    // Ki·ªÉm tra ng√†y hi·ªán t·∫°i v√† so s√°nh v·ªõi ng√†y ƒë√£ l∆∞u ƒë·ªÉ reset cache n·∫øu c·∫ßn
    const currentDate = new Date().toISOString().split('T')[0];  // L·∫•y ng√†y hi·ªán t·∫°i theo ƒë·ªãnh d·∫°ng YYYY-MM-DD
    console.log('Current Date:', currentDate);
    console.log('Last Checked Date:', lastCheckedDate);

    // N·∫øu ng√†y hi·ªán t·∫°i kh√°c ng√†y ƒë√£ ki·ªÉm tra, reset cache
    if (lastCheckedDate !== currentDate) {
        console.log('New day detected. Resetting cache.');
        cachedStaticLogData = {};  // Reset cache
        lastCheckedDate = currentDate;  // C·∫≠p nh·∫≠t ng√†y ki·ªÉm tra m·ªõi
    }

    let logDataArray = [];
    try {
        await Promise.all(logFiles.map(async (logFile) => {
            return new Promise((resolve, reject) => {
                // In ra tr·∫°ng th√°i cache tr∆∞·ªõc khi ki·ªÉm tra
                // console.log(`Checking cache for ${logFile}:`, cachedStaticLogData[logFile]);

                // N·∫øu l√† 'pihole.log' ho·∫∑c log ch∆∞a ƒë∆∞·ª£c cached, th·ª±c hi·ªán ph√¢n t√≠ch
                if (logFile === 'pihole.log' || !cachedStaticLogData[logFile]) {
                    console.log(`Fetching new log data for ${logFile}`); // Debug khi ƒëang g·ªçi d·ªØ li·ªáu m·ªõi

                    exec(`bash ./script/analyze-log.sh ${logFile}`, (err, stdout, stderr) => {
                        if (err) {
                            // console.error('L·ªói khi g·ªçi script:', err);
                            reject('L·ªói x·∫£y ra trong qu√° tr√¨nh th·ª±c thi script');
                        }

                        if (stderr) {
                            console.error('stderr:', stderr);
                            reject('L·ªói x·∫£y ra khi ph√¢n t√≠ch log');
                        }

                        try {
                            const logData = JSON.parse(stdout.trim());
                            // In ra log m·ªõi ƒë·ªÉ debug
                            // console.log(`New log data for ${logFile}:`, logData);

                            if (logFile !== 'pihole.log') {
                                cachedStaticLogData[logFile] = logData;  // L∆∞u d·ªØ li·ªáu log tƒ©nh v√†o cache
                            }
                            logDataArray.push(logData);
                            resolve();
                        } catch (parseError) {
                            // console.error('L·ªói ph√¢n t√≠ch c√∫ ph√°p JSON:', parseError);
                            reject('L·ªói ph√¢n t√≠ch c√∫ ph√°p k·∫øt qu·∫£ t·ª´ script');
                        }
                    });
                } else {
                    // In ra cache khi ƒëang l·∫•y d·ªØ li·ªáu t·ª´ cache
                    // console.log(`Using cached data for ${logFile}:`, cachedStaticLogData[logFile]);

                    logDataArray.push(cachedStaticLogData[logFile]);  // L·∫•y d·ªØ li·ªáu t·ª´ cache cho c√°c file log tƒ©nh
                    resolve();
                }
            });
        }));

        // Kh√¥ng c·∫ßn ƒë·∫£o ng∆∞·ª£c (reverse), v√¨ ch√∫ng ta ƒë√£ truy·ªÅn th·ª© t·ª± ƒë√∫ng t·ª´ ƒë·∫ßu
        // console.log('Returning log data:', logDataArray);  // Debug d·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ API
        res.json(logDataArray);  // Tr·∫£ d·ªØ li·ªáu log ƒë√£ ph√¢n t√≠ch

    } catch (error) {
        console.error('L·ªói t·ªïng:', error);
        res.status(500).json({ error: error });
    }
});

//============================================================================================================================//
// Route x·ª≠ l√Ω t·∫•t c·∫£ c√°c route kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a
app.use((req, res) => {
    res.sendFile(path.join(__dirname, '../public/html', 'error.html'));
});

// Kh·ªüi ƒë·ªông server
const server = app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}/`);
});



// H√†m ƒë·ªÉ l·∫•y d·ªØ li·ªáu session
function getSessionData(sessionId) {
    // Tr·∫£ v·ªÅ th√¥ng tin SSH t·ª´ bi·∫øn to√†n c·ª•c
    return globalSshInfo;
}

